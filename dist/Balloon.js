(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Balloon = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Balloon, Blimp, SurfaceRender, SurfaceUtil, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require("ikagaka.shell.js"), SurfaceRender = ref.SurfaceRender, SurfaceUtil = ref.SurfaceUtil;

  Blimp = require("./Blimp").Blimp;

  Balloon = (function(superClass) {
    extend(Balloon, superClass);

    function Balloon(directory1) {
      this.directory = directory1;
      Balloon.__super__.constructor.call(this);
      this.descript = {};
      this.attachedSurface = [];
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function() {
      return Promise.resolve(this).then((function(_this) {
        return function() {
          return _this.loadDescript();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadBalloonSurfaces();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadBalloonDescripts();
        };
      })(this));
    };

    Balloon.prototype.loadDescript = function() {
      var descript_name, dir, getName;
      dir = this.directory;
      getName = (function(_this) {
        return function(dic, reg) {
          return Object.keys(dic).filter(function(name) {
            return reg.test(name);
          })[0] || "";
        };
      })(this);
      descript_name = getName(dir, /^descript\.txt$/i);
      if (descript_name === "") {
        console.info("descript.txt is not found");
        this.descript = {};
      } else {
        this.descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(dir[descript_name]));
      }
      return Promise.resolve(this);
    };

    Balloon.prototype.loadBalloonDescripts = function() {
      var balloons, descript, directory;
      directory = this.directory;
      balloons = this.balloons;
      descript = this.descript;
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var hits, keys;
          keys = Object.keys(directory);
          hits = keys.filter(function(filepath) {
            return /balloon([sk])(\d+)s\.txt$/.test(filepath);
          });
          hits.forEach(function(filepath) {
            var __, _descript, buffer, n, ref1, type;
            buffer = directory[filepath];
            _descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(buffer));
            ref1 = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = ref1[0], type = ref1[1], n = ref1[2];
            SurfaceUtil.extend(_descript, descript);
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)].descript = _descript;
              case "k":
                return balloons["kero"][Number(n)].descript = _descript;
            }
          });
          return resolve(_this);
        };
      })(this));
    };

    Balloon.prototype.loadBalloonSurfaces = function() {
      var balloons, directory, hits, keys, promises;
      directory = this.directory;
      balloons = this.balloons;
      keys = Object.keys(directory);
      hits = keys.filter(function(filepath) {
        return /[^\/]+\.png$/.test(filepath);
      });
      promises = hits.map(function(filepath) {
        return new Promise(function(resolve, reject) {
          var buffer, url;
          buffer = directory[filepath];
          url = URL.createObjectURL(new Blob([buffer], {
            type: "image/png"
          }));
          return SurfaceUtil.fetchImageFromURL(url).then(function(img) {
            return [null, img];
          })["catch"](function(err) {
            return [err, null];
          }).then(function(arg) {
            var __, err, img, n, ref1, ref2, ref3, rndr, type;
            err = arg[0], img = arg[1];
            if (!!err) {
              return reject(err);
            }
            URL.revokeObjectURL(url);
            if (!!err) {
              return reject(err);
            }
            rndr = new SurfaceRender(SurfaceUtil.copy(img));
            rndr.chromakey();
            if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
              ref1 = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = ref1[0], type = ref1[1], n = ref1[2];
              switch (type) {
                case "s":
                  balloons["sakura"][Number(n)] = {
                    canvas: rndr.cnv
                  };
                  break;
                case "k":
                  balloons["kero"][Number(n)] = {
                    canvas: rndr.cnv
                  };
                  break;
                case "c":
                  balloons["communicate"][Number(n)] = {
                    canvas: rndr.cnv
                  };
              }
            } else if (/^online(\d+)\.png$/.test(filepath)) {
              ref2 = /^online(\d+)\.png$/.exec(filepath), __ = ref2[0], n = ref2[1];
              balloons["online"][Number(n)] = {
                canvas: rndr.cnv
              };
            } else if (/^arrow(\d+)\.png$/.test(filepath)) {
              ref3 = /^arrow(\d+)\.png$/.exec(filepath), __ = ref3[0], n = ref3[1];
              balloons["arrow"][Number(n)] = {
                canvas: rndr.cnv
              };
            } else if (/^sstp\.png$/.test(filepath)) {
              balloons["sstp"] = {
                canvas: rndr.cnv
              };
            } else if (/^thumbnail\.png$/.test(filepath)) {
              balloons["thumbnail"] = {
                canvas: rndr.cnv
              };
            }
            return resolve();
          });
        });
      });
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return Promise.all(promises).then(function() {
            return resolve(_this);
          });
        };
      })(this));
    };

    Balloon.prototype.unload = function() {
      this.attachedBlimp.forEach(function(arg) {
        var blimp, element;
        element = arg.element, blimp = arg.blimp;
        return blimp.destructor();
      });
      this.removeAllListeners();
      Object.keys(this).forEach((function(_this) {
        return function(key) {
          return _this[key] = new _this[key].constructor();
        };
      })(this));
    };

    Balloon.prototype.attachBlimp = function(element, scopeId, balloonId) {
      var blimp, type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (this.balloons[type][balloonId] == null) {
        console.warn("balloon id:", balloonId, "is not defined");
        return null;
      }
      blimp = new Blimp(element, scopeId, balloonId, this);
      this.attachedSurface.push({
        blimp: blimp,
        element: element
      });
      return blimp;
    };

    Balloon.prototype.detachBlimp = function(element) {
      var hits;
      hits = this.attachedBlimp.filter((function(_this) {
        return function(arg) {
          var _element;
          _element = arg.element;
          return _element === element;
        };
      })(this));
      if (hits.length === 0) {
        return;
      }
      hits[0].blimp.destructor();
      this.attachedBlimp.splice(this.attachedBlimp.indexOf(hits[0]), 1);
    };

    return Balloon;

  })(EventEmitter2);

  exports.Balloon = Balloon;

}).call(this);

},{"./Blimp":2,"ikagaka.shell.js":8}],2:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Blimp, SurfaceRender, SurfaceUtil, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = require("ikagaka.shell.js"), SurfaceRender = ref.SurfaceRender, SurfaceUtil = ref.SurfaceUtil;

  Blimp = (function(superClass) {
    extend(Blimp, superClass);

    function Blimp(element, scopeId, balloonId1, balloon) {
      var balloonId, ref1, ref2;
      this.element = element;
      this.scopeId = scopeId;
      this.balloonId = balloonId1;
      this.balloon = balloon;
      this.font = bind(this.font, this);
      this.showWait = bind(this.showWait, this);
      this.br = bind(this.br, this);
      this.clear = bind(this.clear, this);
      this.marker = bind(this.marker, this);
      this.talkraw = bind(this.talkraw, this);
      this.talk = bind(this.talk, this);
      this.choiceEnd = bind(this.choiceEnd, this);
      this.choiceBegin = bind(this.choiceBegin, this);
      this.choice = bind(this.choice, this);
      this.anchorEnd = bind(this.anchorEnd, this);
      this.anchorBegin = bind(this.anchorBegin, this);
      Blimp.__super__.constructor.call(this);
      this.type = this.scopeId === 0 ? "sakura" : "kero";
      this.isBalloonLeft = true;
      balloonId = this.balloonId;
      if (!this.isBalloonLeft) {
        balloonId++;
      }
      this.descript = ((ref1 = this.balloon.balloons[this.type]) != null ? (ref2 = ref1[balloonId]) != null ? ref2.descript : void 0 : void 0) || {};
      this.destructed = false;
      this.destructors = [];
      this.insertPoint = null;
      this.width = 0;
      this.height = 0;
      this.initDOMStructure();
      this.initEventListener();
      this.initStyleFromDescript();
      this.render();
    }

    Blimp.prototype.initDOMStructure = function() {
      this.$blimp = $(this.element).addClass("blimp");
      this.$blimpCanvas = $("<canvas width='0' height='0' />").addClass("blimpCanvas");
      this.$blimpText = $("<div />").addClass("blimpText");
      this.$blimp.append(this.$blimpCanvas);
      this.$blimp.append(this.$blimpText);
      this.$blimp.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "pointer-events": "auto"
      });
      this.$blimpCanvas.css({
        position: "absolute",
        top: "0px",
        left: "0px"
      });
      this.$blimpText.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "overflow-y": "scroll",
        "white-space": "pre-wrap",
        "word-wrap": "break-all"
      });
      $("<style scoepd />").text(".blimpText a {\n  cursor: pointer;\n}\n@keyframes blink {\n  75% { opacity: 0.0; }\n}\n.blimpText .blink {\n  animation: blink 1s step-end infinite;\n}").appendTo(this.$blimp);
      this.insertPoint = this.$blimpText;
    };

    Blimp.prototype.initEventListener = function() {
      var mouselistener, onanchorclick, onchoiceclick;
      mouselistener = (function(_this) {
        return function(ev) {
          var custom;
          custom = {
            type: ev.type,
            scopeId: _this.scopeId,
            balloonId: _this.balloonId,
            event: ev
          };
          _this.emit("mouse", custom);
          return _this.balloon.emit("mouse", custom);
        };
      })(this);
      this.$blimp.on("click", mouselistener);
      this.$blimp.on("dblclick", mouselistener);
      this.$blimp.on("mousemove", mouselistener);
      this.$blimp.on("mousedown", mouselistener);
      this.$blimp.on("mouseup", mouselistener);
      onchoiceclick = (function(_this) {
        return function(ev) {
          var argc, event, i, j, ref1;
          event = {
            type: "choiceselect",
            id: ev.target.dataset["id"],
            args: [],
            text: ev.target.textContent
          };
          argc = Number(ev.target.dataset["argc"]);
          for (i = j = 0, ref1 = argc; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            event.args.push(ev.target.dataset["argv" + i]);
          }
          _this.emit("select", event);
          return _this.balloon.emit("select", event);
        };
      })(this);
      this.$blimp.on("click", ".ikagaka-choice", onchoiceclick);
      onanchorclick = (function(_this) {
        return function(ev) {
          var argc, event, i, j, ref1;
          event = {
            type: "anchorselect",
            id: ev.target.dataset["id"],
            args: [],
            text: ev.target.textContent
          };
          argc = Number(ev.target.dataset["argc"]);
          for (i = j = 0, ref1 = argc; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
            event.args.push(ev.target.dataset["argv" + i]);
          }
          _this.emit("select", event);
          return _this.balloon.emit("select", event);
        };
      })(this);
      this.$blimp.on("click", ".ikagaka-anchor", onanchorclick);
      this.destructors.push((function(_this) {
        return function() {
          _this.$blimp.off("click", mouselistener);
          _this.$blimp.off("dblclick", mouselistener);
          _this.$blimp.off("click", ".ikagaka-choice", onchoiceclick);
          return _this.$blimp.off("click", ".ikagaka-anchor", onanchorclick);
        };
      })(this));
    };

    Blimp.prototype.initStyleFromDescript = function() {
      var clickable_element_style, descript;
      descript = this.balloon.descript;
      this._text_style = {
        "cursor": descript["cursor"] || '',
        "font.name": (descript["font.name"] || "MS Gothic").split(/,/).map(function(name) {
          return '"' + name + '"';
        }).join(','),
        "font.height": (descript["font.height"] || "12") + "px",
        "font.color": this._getFontColor(descript["font.color.r"], descript["font.color.g"], descript["font.color.b"]),
        "font.shadowcolor": this._getFontColor(descript["font.shadowcolor.r"], descript["font.shadowcolor.g"], descript["font.shadowcolor.b"], true),
        "font.bold": descript["font.bold"],
        "font.italic": descript["font.italic"],
        "font.strike": descript["font.strike"],
        "font.underline": descript["font.underline"]
      };
      clickable_element_style = (function(_this) {
        return function(prefix, style_default, descript, can_ignore) {
          return {
            "style": {
              square: true,
              underline: true,
              'square+underline': true,
              none: true
            }[descript[prefix + ".style"]] ? descript[prefix + ".style"] : style_default,
            "font.color": _this._getFontColor(descript[prefix + ".font.color.r"], descript[prefix + ".font.color.g"], descript[prefix + ".font.color.b"], can_ignore),
            "pen.color": _this._getFontColor(descript[prefix + ".pen.color.r"], descript[prefix + ".pen.color.g"], descript[prefix + ".pen.color.b"], can_ignore),
            "brush.color": _this._getFontColor(descript[prefix + ".brush.color.r"], descript[prefix + ".brush.color.g"], descript[prefix + ".brush.color.b"], can_ignore)
          };
        };
      })(this);
      this._choice_style = clickable_element_style("cursor", "square", descript);
      this._choice_notselect_style = clickable_element_style("cursor.notselect", void 0, descript, true);
      this._anchor_style = clickable_element_style("anchor", "underline", descript);
      this._anchor_notselect_style = clickable_element_style("anchor.notselect", void 0, descript, true);
      this.$blimpText.css(this._blimpTextCSS(this._text_style));
      this._initializeCurrentStyle();
    };

    Blimp.prototype._blimpTextCSS = function(styles) {
      var css, text_decoration;
      css = {};
      css["cursor"] = styles["cursor"];
      css["font-family"] = styles["font.name"];
      css["font-size"] = styles["font.height"];
      css["color"] = styles["font.color"];
      css["background"] = "none";
      css["outline"] = "none";
      css["border"] = "none";
      css["text-shadow"] = styles["font.shadowcolor"] ? "1px 1px 0 " + styles["font.shadowcolor"] : "none";
      css["font-weight"] = styles["font.bold"] ? "bold" : "normal";
      css["font-style"] = styles["font.italic"] ? "italic" : "normal";
      text_decoration = [];
      if (styles["font.strike"]) {
        text_decoration.push('line-through');
      }
      if (styles["font.underline"]) {
        text_decoration.push('underline');
      }
      css["text-decoration"] = text_decoration.length ? text_decoration.join(' ') : "none";
      css["line-height"] = "1.2em";
      return css;
    };

    Blimp.prototype._blimpClickableTextCSS = function(styles, default_styles) {
      var background, border_bottom, color, outline;
      if (default_styles == null) {
        default_styles = {};
      }
      color = styles["font.color"] || default_styles["font.color"];
      outline = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      background = styles["brush.color"] || default_styles["brush.color"] || default_styles["font.color"];
      border_bottom = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      switch (styles["style"]) {
        case "square":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              "border-bottom": "none"
            }
          };
        case "underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              'border-bottom': border_bottom
            }
          };
        case "square+underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              'border-bottom': border_bottom
            }
          };
        case "none":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              "border-bottom": "none"
            }
          };
        default:
          return {
            base: {},
            over: {}
          };
      }
    };

    Blimp.prototype._initializeCurrentStyle = function() {
      var name, ref1, ref2, ref3, ref4, ref5, value;
      this._current_text_style = {};
      ref1 = this._text_style;
      for (name in ref1) {
        value = ref1[name];
        this._current_text_style[name] = value;
      }
      this._current_choice_style = {};
      ref2 = this._choice_style;
      for (name in ref2) {
        value = ref2[name];
        this._current_choice_style[name] = value;
      }
      this._current_choice_notselect_style = {};
      ref3 = this._choice_notselect_style;
      for (name in ref3) {
        value = ref3[name];
        this._current_choice_notselect_style[name] = value;
      }
      this._current_anchor_style = {};
      ref4 = this._anchor_style;
      for (name in ref4) {
        value = ref4[name];
        this._current_anchor_style[name] = value;
      }
      this._current_anchor_notselect_style = {};
      ref5 = this._anchor_notselect_style;
      for (name in ref5) {
        value = ref5[name];
        this._current_anchor_notselect_style[name] = value;
      }
    };

    Blimp.prototype._getFontColor = function(r, g, b, can_ignore) {
      var bc, gc, rc;
      rc = r != null ? r.replace(/%$/, '') : void 0;
      gc = g != null ? g.replace(/%$/, '') : void 0;
      bc = b != null ? b.replace(/%$/, '') : void 0;
      if ((isNaN(rc) || rc < 0) && (isNaN(gc) || gc < 0) && (isNaN(bc) || bc < 0)) {
        if (can_ignore) {

        } else {
          return "rgb(0,0,0)";
        }
      } else {
        return "rgb(" + r + "," + g + "," + b + ")";
      }
    };

    Blimp.prototype.location = function(x, y) {
      var $imp_position_checker, $newimp, $newimp_container, $newimp_container_top, baseoffset, offset, offsetx, offsety, re, toparam, xp, yp;
      re = /^(@)?(-?\d*\.?\d*e?\d*)(em|%)?$/;
      toparam = (function(_this) {
        return function(r) {
          var rp, unit, value;
          r = r + "";
          if (!r.length) {
            return {
              relative: true,
              value: 0
            };
          }
          rp = r.match(re);
          if (!rp) {
            return;
          }
          if (isNaN(rp[2])) {
            return;
          }
          if (rp[3] === '%') {
            value = rp[2] / 100;
            unit = 'em';
          } else {
            value = Number(rp[2]);
            unit = rp[3] || 'px';
          }
          return {
            relative: !!rp[1],
            value: value + unit
          };
        };
      })(this);
      xp = toparam(x);
      yp = toparam(y);
      if (!((xp != null) && (yp != null))) {
        return;
      }
      if (xp.relative || yp.relative) {
        $imp_position_checker = $('<span>.</span>');
        this.insertPoint.append($imp_position_checker);
        offset = $imp_position_checker.offset();
        baseoffset = this.$blimpText.offset();
        offsetx = offset.left - baseoffset.left;
        offsety = offset.top - baseoffset.top + this.$blimpText.scrollTop();
        $imp_position_checker.remove();
      }
      if (!xp.relative) {
        offsetx = 0;
      }
      if (!yp.relative) {
        offsety = 0;
      }
      $newimp_container_top = $('<div />').addClass("newimp_container_top").css({
        'position': 'absolute',
        'pointer-events': 'none',
        'top': yp.value
      });
      $newimp_container = $('<div />').addClass("newimp_container").css({
        'position': 'absolute',
        'pointer-events': 'none',
        'text-indent': offsetx + 'px',
        'top': offsety + 'px',
        'width': this.$blimpText[0].clientWidth
      });
      $newimp = $('<span />').css({
        'pointer-events': 'auto',
        'margin-left': xp.value
      });
      this.insertPoint = $newimp.appendTo($newimp_container.appendTo($newimp_container_top.appendTo(this.$blimpText)));
      this.insertPoint.css(this._blimpTextCSS(this._current_text_style));
    };

    Blimp.prototype.destructor = function() {
      this.destructor = (function(_this) {
        return function() {
          return console.warn("this blimp was already destructed", _this);
        };
      })(this);
      this.destructors.forEach((function(_this) {
        return function(fn) {
          return fn();
        };
      })(this));
      this.destructed = true;
      this.$blimp.removeClass("blimp");
      this.$blimp.children().remove();
      this.balloon = null;
    };

    Blimp.prototype.render = function() {
      var b, balloonId, baseCanvas, descript, h, l, r, ref1, ref2, rndr, t, w;
      balloonId = this.balloonId;
      if (!this.isBalloonLeft) {
        balloonId++;
      }
      baseCanvas = this.balloon.balloons[this.type][balloonId].canvas;
      this.descript = ((ref1 = this.balloon.balloons[this.type]) != null ? (ref2 = ref1[balloonId]) != null ? ref2.descript : void 0 : void 0) || {};
      rndr = new SurfaceRender(this.$blimpCanvas[0]);
      rndr.init(baseCanvas);
      this.$blimp.width(this.width = this.$blimpCanvas[0].width);
      this.$blimp.height(this.height = this.$blimpCanvas[0].height);
      descript = this.descript;
      t = descript["origin.y"] || descript["validrect.top"] || "10";
      r = descript["validrect.right"] || "10";
      b = descript["validrect.bottom"] || "10";
      l = descript["origin.x"] || descript["validrect.left"] || "10";
      w = this.$blimpCanvas[0].width;
      h = this.$blimpCanvas[0].height;
      this.$blimpText.css({
        top: t + "px",
        left: l + "px",
        width: (w - (Number(l) + Number(r))) + "px",
        height: (h - (Number(t) - Number(b))) + "px"
      });
    };

    Blimp.prototype.left = function() {
      this.isBalloonLeft = true;
      return this.render();
    };

    Blimp.prototype.right = function() {
      this.isBalloonLeft = false;
      return this.render();
    };

    Blimp.prototype.surface = function(balloonId) {
      balloonId - balloonId % 2;
      if (!this.isBalloonLeft) {
        balloonId++;
      }
      this.balloonId = balloonId;
      return this.render();
    };

    Blimp.prototype.anchorBegin = function() {
      var $a, _id, anchor_css, anchor_notselect_css, args, argv, id, index, j, len, text_css;
      id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.$blimpText.find(".blink").hide();
      this.$blimp.show();
      _id = $(document.createElement("div")).text(id).html();
      $a = $("<a />");
      $a.addClass("ikagaka-anchor");
      text_css = this._blimpTextCSS(this._current_text_style);
      anchor_css = this._blimpClickableTextCSS(this._current_anchor_style);
      anchor_notselect_css = this._blimpClickableTextCSS(this._current_anchor_notselect_style, this._current_anchor_style);
      $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
      $a.mouseover((function(_this) {
        return function() {
          return $a.css(anchor_css.over);
        };
      })(this));
      $a.mouseout((function(_this) {
        return function() {
          return $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
        };
      })(this));
      $a.attr("data-id", _id);
      $a.attr("data-argc", args.length);
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        argv = args[index];
        $a.attr("data-argv" + index, argv);
      }
      this.originalInsertPoint = this.insertPoint;
      this.insertPoint = $a.appendTo(this.insertPoint);
    };

    Blimp.prototype.anchorEnd = function() {
      this.insertPoint = this.originalInsertPoint;
    };

    Blimp.prototype.choice = function() {
      var $a, _id, _text, args, argv, choice_css, choice_notselect_css, id, index, j, len, text, text_css;
      text = arguments[0], id = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.$blimpText.find(".blink").hide();
      this.$blimp.show();
      _text = $(document.createElement("div")).text(text).html();
      _id = $(document.createElement("div")).text(id).html();
      $a = $("<a />");
      $a.addClass("ikagaka-choice");
      text_css = this._blimpTextCSS(this._current_text_style);
      choice_css = this._blimpClickableTextCSS(this._current_choice_style);
      choice_notselect_css = this._blimpClickableTextCSS(this._current_choice_notselect_style, this._current_text_style);
      $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
      $a.mouseover((function(_this) {
        return function() {
          return $a.css(choice_css.base).css(choice_css.over);
        };
      })(this));
      $a.mouseout((function(_this) {
        return function() {
          return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
        };
      })(this));
      $a.html(_text);
      $a.attr("data-id", _id);
      $a.attr("data-argc", args.length);
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        argv = args[index];
        $a.attr("data-argv" + index, argv);
      }
      $a.appendTo(this.insertPoint);
    };

    Blimp.prototype.choiceBegin = function() {
      var $a, _id, args, argv, choice_css, choice_notselect_css, id, index, j, len, text_css;
      id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.$blimpText.find(".blink").hide();
      this.$blimp.show();
      _id = $(document.createElement("div")).text(id).html();
      $a = $("<a />");
      $a.addClass("ikagaka-choice");
      text_css = this._blimpTextCSS(this._current_text_style);
      choice_css = this._blimpClickableTextCSS(this._current_choice_style);
      choice_notselect_css = this._blimpClickableTextCSS(this._current_choice_notselect_style, this._current_text_style);
      $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
      $a.mouseover((function(_this) {
        return function() {
          return $a.css(choice_css.base).css(choice_css.over);
        };
      })(this));
      $a.mouseout((function(_this) {
        return function() {
          return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
        };
      })(this));
      $a.attr("data-id", _id);
      $a.attr("data-argc", args.length);
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        argv = args[index];
        $a.attr("data-argv" + index, argv);
      }
      this.originalInsertPoint = this.insertPoint;
      this.insertPoint = $a.appendTo(this.insertPoint);
    };

    Blimp.prototype.choiceEnd = function() {
      this.insertPoint = this.originalInsertPoint;
    };

    Blimp.prototype.talk = function(text) {
      var _text;
      this.$blimpText.find(".blink").hide();
      _text = $(document.createElement("div")).text(text).html();
      if (!!this.currentSurface) {
        this.currentSurface.talk();
      }
      this.$blimp.show();
      this.insertPoint.append(_text);
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.talkraw = function(text) {
      this.$blimpText.find(".blink").hide();
      if (!!this.currentSurface) {
        this.currentSurface.talk();
      }
      this.$blimp.show();
      this.insertPoint.append(text);
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.marker = function() {
      var _text;
      this.$blimpText.find(".blink").hide();
      _text = $(document.createElement("div")).text("・").html();
      this.$blimp.show();
      this.insertPoint.append(_text);
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.clear = function() {
      this.$blimpText.html("");
      this.insertPoint = this.$blimpText;
      this._initializeCurrentStyle();
    };

    Blimp.prototype.br = function(ratio) {
      if (ratio != null) {
        this.location('0', '@' + ratio + 'em');
      } else {
        this.insertPoint.append("<br />");
      }
    };

    Blimp.prototype.showWait = function() {
      this.insertPoint.append("<br /><br />").append("<div class='blink'>▼</div>");
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.font = function() {
      var $newimp, $size_checker, is_text_style, name, size, treat_bool, treat_clickable_styles, value, values;
      name = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      value = values[0];
      treat_bool = (function(_this) {
        return function(name, value) {
          if (value === 'default') {
            return _this._current_text_style["font." + name] = _this._text_style["font." + name];
          } else {
            return _this._current_text_style["font." + name] = !((value === 'false') || ((value - 0) === 0));
          }
        };
      })(this);
      treat_clickable_styles = (function(_this) {
        return function(treat_name, name, value, values, _current_style, _style) {
          switch (name) {
            case treat_name + "style":
              if (value === 'default') {
                return _current_style["style"] = _style["style"];
              } else {
                return _current_style["style"] = value;
              }
              break;
            case treat_name + "fontcolor":
              if (value === 'default') {
                return _current_style["font.color"] = _style["font.color"];
              } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                return _current_style["font.color"] = _this._getFontColor(values[0], values[1], values[2]);
              } else {
                return _current_style["font.color"] = value;
              }
              break;
            case treat_name + "pencolor":
              if (value === 'default') {
                return _current_style["pen.color"] = _style["pen.color"];
              } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                return _current_style["pen.color"] = _this._getpenColor(values[0], values[1], values[2]);
              } else {
                return _current_style["pen.color"] = value;
              }
              break;
            case treat_name + "color":
            case treat_name + "brushcolor":
              if (value === 'default') {
                return _current_style["brush.color"] = _style["brush.color"];
              } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                return _current_style["brush.color"] = _this._getFontColor(values[0], values[1], values[2]);
              } else {
                return _current_style["brush.color"] = value;
              }
          }
        };
      })(this);
      switch (name) {
        case 'name':
          is_text_style = true;
          this._current_text_style["font.name"] = values.map(function(name) {
            return '"' + name + '"';
          }).join(',');
          break;
        case 'height':
          is_text_style = true;
          if (value === 'default') {
            this._current_text_style["font.height"] = this._text_style["font.height"];
          } else if (/^[+-]/.test(value)) {
            $size_checker = $('<span />').text('I').css({
              position: 'absolute',
              visibility: 'hidden',
              'width': '1em',
              'font-size': '1em',
              padding: 0,
              'line-height': '1em'
            });
            this.insertPoint.append($size_checker);
            size = $size_checker[0].clientHeight;
            $size_checker.remove();
            this._current_text_style["font.height"] = (Number(size) + Number(value)) + 'px';
          } else if (!isNaN(value)) {
            this._current_text_style["font.height"] = value + 'px';
          } else {
            this._current_text_style["font.height"] = value;
          }
          break;
        case 'color':
          is_text_style = true;
          if (value === 'default') {
            this._current_text_style["font.color"] = this._text_style["font.color"];
          } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
            this._current_text_style["font.color"] = this._getFontColor(values[0], values[1], values[2]);
          } else {
            this._current_text_style["font.color"] = value;
          }
          break;
        case 'shadowcolor':
          is_text_style = true;
          if (value === 'default') {
            this._current_text_style["font.shadowcolor"] = this._text_style["font.shadowcolor"];
          } else if (value === 'none') {
            this._current_text_style["font.shadowcolor"] = void 0;
          } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
            this._current_text_style["font.shadowcolor"] = this._getFontColor(values[0], values[1], values[2]);
          } else {
            this._current_text_style["font.shadowcolor"] = value;
          }
          break;
        case 'bold':
          is_text_style = true;
          treat_bool('bold', value);
          break;
        case 'italic':
          is_text_style = true;
          treat_bool('italic', value);
          break;
        case 'strike':
          is_text_style = true;
          treat_bool('strike', value);
          break;
        case 'underline':
          is_text_style = true;
          treat_bool('underline', value);
          break;
        case 'default':
          is_text_style = true;
          this._initializeCurrentStyle();
          break;
        case 'cursorstyle':
        case 'cursorfontcolor':
        case 'cursorpencolor':
        case 'cursorcolor':
        case 'cursorbrushcolor':
          treat_clickable_styles('cursor', name, value, values, this._current_choice_style, this._choice_style);
          break;
        case 'anchorstyle':
        case 'anchorfontcolor':
        case 'anchorpencolor':
        case 'anchorcolor':
        case 'anchorbrushcolor':
          treat_clickable_styles('anchor', name, value, values, this._current_anchor_style, this._anchor_style);
          break;
        case 'cursornotselectstyle':
        case 'cursornotselectfontcolor':
        case 'cursornotselectpencolor':
        case 'cursornotselectcolor':
        case 'cursornotselectbrushcolor':
          treat_clickable_styles('cursornotselect', name, value, values, this._current_choice_notselect_style, this._choice_notselect_style);
          break;
        case 'anchornotselectstyle':
        case 'anchornotselectfontcolor':
        case 'anchornotselectpencolor':
        case 'anchornotselectcolor':
        case 'anchornotselectbrushcolor':
          treat_clickable_styles('anchornotselect', name, value, values, this._current_anchor_notselect_style, this._anchor_notselect_style);
      }
      if (is_text_style) {
        $newimp = $('<span />');
        this.insertPoint = $newimp.appendTo(this.insertPoint);
        this.insertPoint.css(this._blimpTextCSS(this._current_text_style));
      }
    };

    return Blimp;

  })(EventEmitter2);

  exports.Blimp = Blimp;

}).call(this);

},{"ikagaka.shell.js":8}],3:[function(require,module,exports){
// Generated by CoffeeScript 1.10.0
(function() {
  var Balloon, Blimp;

  Balloon = require("./Balloon").Balloon;

  Blimp = require("./Blimp").Blimp;

  exports.Balloon = Balloon;

  exports.Blimp = Blimp;

}).call(this);

},{"./Balloon":1,"./Blimp":2}],4:[function(require,module,exports){
/// <reference path="../typings/tsd.d.ts"/>
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _Surface = require('./Surface');

var _SurfaceRender = require("./SurfaceRender");

var _SurfaceUtil = require("./SurfaceUtil");

var SurfaceUtil = _interopRequireWildcard(_SurfaceUtil);

var Shell = (function (_EventEmitter2) {
    _inherits(Shell, _EventEmitter2);

    function Shell(directory) {
        _classCallCheck(this, Shell);

        _get(Object.getPrototypeOf(Shell.prototype), "constructor", this).call(this);
        EventEmitter2.call(this);
        this.descript = {};
        this.directory = directory;
        this.attachedSurface = [];
        this.surfacesTxt = {};
        this.surfaceTree = [];
        this.cacheCanvas = {};
        this.bindgroup = [];
        this.enableRegionDraw = false;
    }

    _createClass(Shell, [{
        key: "load",
        value: function load() {
            var _this = this;

            return Promise.resolve(this).then(function () {
                return _this.loadDescript();
            }) // 1st // ←なにこれ（自問自
            .then(function () {
                return _this.loadBindGroup();
            }) // 2nd // 依存関係的なやつだと思われ
            .then(function () {
                return _this.loadSurfacesTxt();
            }) // 1st
            .then(function () {
                return _this.loadSurfaceTable();
            }) // 1st
            .then(function () {
                return _this.loadSurfacePNG();
            }) // 2nd
            .then(function () {
                return _this.loadCollisions();
            }) // 3rd
            .then(function () {
                return _this.loadAnimations();
            }) // 3rd
            .then(function () {
                return _this.loadElements();
            }) // 3rd
            ["catch"](function (err) {
                console.error("Shell#load > ", err);
                return Promise.reject(err);
            });
        }

        // load descript and assign to this.descript
    }, {
        key: "loadDescript",
        value: function loadDescript() {
            var dir = this.directory;
            var getName = function getName(dic, reg) {
                return Object.keys(dic).filter(function (name) {
                    return reg.test(name);
                })[0] || "";
            };
            var descript_name = getName(dir, /^descript\.txt$/i);
            if (descript_name === "") {
                console.info("descript.txt is not found");
                this.descript = {};
            } else {
                this.descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(dir[descript_name]));
            }
            return Promise.resolve(this);
        }

        // load bindgroup and assign to this.bindgroup
    }, {
        key: "loadBindGroup",
        value: function loadBindGroup() {
            var _this2 = this;

            var descript = this.descript;
            var grep = function grep(dic, reg) {
                return Object.keys(dic).filter(function (key) {
                    return reg.test(key);
                });
            };
            var reg = /^(sakura|kero|char\d+)\.bindgroup(\d+)\.default/;
            grep(descript, reg).forEach(function (key) {
                var _reg$exec = reg.exec(key);

                var _reg$exec2 = _slicedToArray(_reg$exec, 3);

                var _ = _reg$exec2[0];
                var charId = _reg$exec2[1];
                var bindgroupId = _reg$exec2[2];

                var _charId = charId === "sakura" ? "0" : "kero" ? "1" : (/char(\d+)/.exec(charId) || ["", Number.NaN])[1];
                var maybeNumCharId = Number(_charId);
                var maybeNumBindgroupId = Number(bindgroupId);
                var maybeNumBool = Number(descript[key]);
                if (isFinite(maybeNumCharId) && isFinite(maybeNumBindgroupId)) {
                    _this2.bindgroup[maybeNumCharId] = _this2.bindgroup[maybeNumCharId] || [];
                    _this2.bindgroup[maybeNumCharId][maybeNumBindgroupId] = maybeNumBool === 1 ? true : false;
                } else {
                    console.warn("CharId: " + _charId + " or bindgroupId: " + bindgroupId + " is not number");
                }
            });
            return Promise.resolve(this);
        }

        // load surfaces.txt
    }, {
        key: "loadSurfacesTxt",
        value: function loadSurfacesTxt() {
            var _this3 = this;

            var surfaces_text_names = Object.keys(this.directory).filter(function (name) {
                return (/^surfaces.*\.txt$|^alias\.txt$/i.test(name)
                );
            });
            if (surfaces_text_names.length === 0) {
                console.info("surfaces.txt is not found");
                this.surfacesTxt = { surfaces: {}, descript: {}, aliases: {}, regions: {} };
            } else {
                surfaces_text_names.forEach(function (filename) {
                    var text = SurfaceUtil.convert(_this3.directory[filename]);
                    var srfs = SurfacesTxt2Yaml.txt_to_data(text, { compatible: 'ssp-lazy' });
                    SurfaceUtil.extend(_this3.surfacesTxt, srfs);
                });
                //{ expand inherit and remove
                Object.keys(this.surfacesTxt.surfaces).forEach(function (name) {
                    if (typeof _this3.surfacesTxt.surfaces[name].is === "number" && Array.isArray(_this3.surfacesTxt.surfaces[name].base)) {
                        _this3.surfacesTxt.surfaces[name].base.forEach(function (key) {
                            SurfaceUtil.extend(_this3.surfacesTxt.surfaces[name], _this3.surfacesTxt.surfaces[key]);
                        });
                        delete _this3.surfacesTxt.surfaces[name].base;
                    }
                });
                Object.keys(this.surfacesTxt.surfaces).forEach(function (name) {
                    if (typeof _this3.surfacesTxt.surfaces[name].is === "undefined") {
                        delete _this3.surfacesTxt.surfaces[name];
                    }
                });
            }
            return Promise.resolve(this);
        }

        // load surfacetable.txt
    }, {
        key: "loadSurfaceTable",
        value: function loadSurfaceTable() {
            var surfacetable_name = Object.keys(this.directory).filter(function (name) {
                return (/^surfacetable.*\.txt$/i.test(name)
                );
            })[0] || "";
            if (surfacetable_name === "") {
                console.info("surfacetable.txt is not found.");
            } else {
                var txt = SurfaceUtil.convert(this.directory[surfacetable_name]);
            }
            return Promise.resolve(this);
        }

        // load surface*.png and surface*.pna
    }, {
        key: "loadSurfacePNG",
        value: function loadSurfacePNG() {
            var _this4 = this;

            var surface_names = Object.keys(this.directory).filter(function (filename) {
                return (/^surface(\d+)\.png$/i.test(filename)
                );
            });
            var prms = surface_names.map(function (filename) {
                var n = Number(/^surface(\d+)\.png$/i.exec(filename)[1]);
                return _this4.getPNGFromDirectory(filename).then(function (cnv) {
                    if (!_this4.surfaceTree[n]) {
                        _this4.surfaceTree[n] = {
                            base: cnv,
                            elements: [],
                            collisions: [],
                            animations: []
                        };
                    } else {
                        _this4.surfaceTree[n].base = cnv;
                    }
                })["catch"](function (err) {
                    console.warn("Shell#loadSurfacePNG > " + err);
                    return Promise.resolve();
                });
            });
            return Promise.all(prms).then(function () {
                return Promise.resolve(_this4);
            });
        }

        // load elements
    }, {
        key: "loadElements",
        value: function loadElements() {
            var _this5 = this;

            var srfs = this.surfacesTxt.surfaces;
            var hits = Object.keys(srfs).filter(function (name) {
                return !!srfs[name].elements;
            });
            var prms = hits.map(function (defname) {
                var n = srfs[defname].is;
                var elms = srfs[defname].elements;
                var _prms = Object.keys(elms).map(function (elmname) {
                    var _elms$elmname = elms[elmname];
                    var is = _elms$elmname.is;
                    var type = _elms$elmname.type;
                    var file = _elms$elmname.file;
                    var x = _elms$elmname.x;
                    var y = _elms$elmname.y;

                    return _this5.getPNGFromDirectory(file).then(function (canvas) {
                        if (!_this5.surfaceTree[n]) {
                            _this5.surfaceTree[n] = {
                                base: SurfaceUtil.createCanvas(),
                                elements: [],
                                collisions: [],
                                animations: []
                            };
                        }
                        _this5.surfaceTree[n].elements[is] = { type: type, canvas: canvas, x: x, y: y };
                        return Promise.resolve(_this5);
                    })["catch"](function (err) {
                        console.warn("Shell#loadElements > " + err);
                        return Promise.resolve(_this5);
                    });
                });
                return Promise.all(_prms).then(function () {
                    return Promise.resolve(_this5);
                });
            });
            return Promise.all(prms).then(function () {
                return Promise.resolve(_this5);
            });
        }

        // load collisions
    }, {
        key: "loadCollisions",
        value: function loadCollisions() {
            var _this6 = this;

            var srfs = this.surfacesTxt.surfaces;
            Object.keys(srfs).filter(function (name) {
                return !!srfs[name].regions;
            }).forEach(function (defname) {
                var n = srfs[defname].is;
                var regions = srfs[defname].regions;
                Object.keys(regions).forEach(function (regname) {
                    if (!_this6.surfaceTree[n]) {
                        _this6.surfaceTree[n] = {
                            base: SurfaceUtil.createCanvas(),
                            elements: [],
                            collisions: [],
                            animations: []
                        };
                    }
                    var is = regions[regname].is;

                    _this6.surfaceTree[n].collisions[is] = regions[regname];
                });
            });
            return Promise.resolve(this);
        }

        // load animations
    }, {
        key: "loadAnimations",
        value: function loadAnimations() {
            var _this7 = this;

            var srfs = this.surfacesTxt.surfaces;
            Object.keys(srfs).filter(function (name) {
                return !!srfs[name].animations;
            }).forEach(function (defname) {
                var n = srfs[defname].is;
                var animations = srfs[defname].animations;
                Object.keys(animations).forEach(function (animname) {
                    if (!_this7.surfaceTree[n]) {
                        _this7.surfaceTree[n] = {
                            base: SurfaceUtil.createCanvas(),
                            elements: [],
                            collisions: [],
                            animations: []
                        };
                    }
                    var _animations$animname = animations[animname];
                    var is = _animations$animname.is;
                    var interval = _animations$animname.interval;

                    _this7.surfaceTree[n].animations[is] = animations[animname];
                });
            });
            return Promise.resolve(this);
        }
    }, {
        key: "hasFile",
        value: function hasFile(filename) {
            return SurfaceUtil.find(Object.keys(this.directory), filename).length > 0;
        }
    }, {
        key: "getPNGFromDirectory",
        value: function getPNGFromDirectory(filename) {
            var _this8 = this;

            var cached_filename = SurfaceUtil.find(Object.keys(this.cacheCanvas), filename)[0] || "";
            if (cached_filename !== "") {
                return Promise.resolve(this.cacheCanvas[cached_filename]);
            }
            if (!this.hasFile(filename)) {
                filename += ".png";
                if (!this.hasFile(filename)) {
                    return Promise.reject(new Error("no such file in directory: " + filename.replace(/\.png$/i, "")));
                }
                console.warn("element file " + filename + " need '.png' extension");
            }
            var _filename = SurfaceUtil.find(Object.keys(this.directory), filename)[0];
            var pnafilename = _filename.replace(/\.png$/i, ".pna");
            var _pnafilename = SurfaceUtil.find(Object.keys(this.directory), pnafilename)[0] || "";
            var pngbuf = this.directory[_filename];
            var pnabuf = this.directory[_pnafilename];
            var render = new _SurfaceRender.SurfaceRender(SurfaceUtil.createCanvas());
            return SurfaceUtil.fetchImageFromArrayBuffer(pngbuf).then(function (img) {
                render.init(img);
                if (_pnafilename === "") {
                    render.chromakey();
                    _this8.cacheCanvas[_filename] = render.cnv;
                    return render.cnv;
                }
                return SurfaceUtil.fetchImageFromArrayBuffer(pnabuf).then(function (pnaimg) {
                    render.pna(SurfaceUtil.copy(pnaimg));
                    _this8.cacheCanvas[_filename] = render.cnv;
                    return render.cnv;
                });
            });
        }
    }, {
        key: "attachSurface",
        value: function attachSurface(canvas, scopeId, surfaceId) {
            var type = SurfaceUtil.scope(scopeId);
            if (typeof surfaceId === "string") {
                if (!!this.surfacesTxt.aliases && !!this.surfacesTxt.aliases[type] && !!this.surfacesTxt.aliases[type][surfaceId]) {
                    var _surfaceId = SurfaceUtil.choice(this.surfacesTxt.aliases[type][surfaceId]);
                } else throw new Error("ReferenceError: surface alias scope:" + type + ", id:" + surfaceId + " is not defined.");
            } else if (typeof surfaceId === "number") {
                var _surfaceId = surfaceId;
            } else throw new Error("TypeError: surfaceId: number|string is not match " + typeof surfaceId);
            var hits = this.attachedSurface.filter(function (_ref) {
                var _canvas = _ref.canvas;
                return _canvas === canvas;
            });
            if (hits.length !== 0) throw new Error("ReferenceError: this HTMLCanvasElement is already attached");
            if (scopeId < 0) {
                throw new Error("TypeError: scopeId needs more than 0, but:" + scopeId);
            }
            if (!this.surfaceTree[surfaceId]) {
                console.warn("surfaceId:", surfaceId, "is not defined");
                return null;
            }
            var srf = new _Surface.Surface(canvas, scopeId, _surfaceId, this);
            this.attachedSurface.push({ canvas: canvas, surface: srf });
            return srf;
        }
    }, {
        key: "detachSurface",
        value: function detachSurface(canvas) {
            var hits = this.attachedSurface.filter(function (_ref2) {
                var _canvas = _ref2.canvas;
                return _canvas === canvas;
            });
            if (hits.length === 0) return;
            hits[0].surface.destructor();
            this.attachedSurface.splice(this.attachedSurface.indexOf(hits[0]), 1);
        }
    }, {
        key: "unload",
        value: function unload() {
            var _this9 = this;

            this.attachedSurface.forEach(function (_ref3) {
                var canvas = _ref3.canvas;
                var surface = _ref3.surface;

                surface.destructor();
            });
            this.removeAllListeners();
            Object.keys(this).forEach(function (key) {
                _this9[key] = new _this9[key].constructor();
            });
        }

        // サーフェスエイリアス込みでサーフェスが存在するか確認
    }, {
        key: "hasSurface",
        value: function hasSurface(scopeId, surfaceId) {
            var type = SurfaceUtil.scope(scopeId);
            if (typeof surfaceId === "string") {
                if (!!this.surfacesTxt.aliases && !!this.surfacesTxt.aliases[type] && !!this.surfacesTxt.aliases[type][surfaceId]) {
                    var _surfaceId = SurfaceUtil.choice(this.surfacesTxt.aliases[type][surfaceId]);
                } else {
                    throw new Error("RuntimeError: surface alias scope:" + type + ", id:" + surfaceId + " is not defined.");
                }
            } else if (typeof surfaceId === "number") {
                var _surfaceId = surfaceId;
            } else throw new Error("TypeError: surfaceId: number|string is not match " + typeof surfaceId);
            return this.surfaceTree[_surfaceId] != null;
        }

        // 着せ替えオン
    }, {
        key: "bind",
        value: function bind(scopeId, bindgroupId) {
            if (this.bindgroup[scopeId] == null) {
                console.warn("Shell#bind > bindgroup", "scopeId:", scopeId, "bindgroupId:", bindgroupId, "is not defined");
                return;
            }
            this.bindgroup[scopeId][bindgroupId] = true;
            this.attachedSurface.forEach(function (_ref4) {
                var srf = _ref4.surface;
                var canvas = _ref4.canvas;

                srf.updateBind();
            });
        }

        // 着せ替えオフ
    }, {
        key: "unbind",
        value: function unbind(scopeId, bindgroupId) {
            if (this.bindgroup[scopeId] == null) {
                console.warn("Shell#unbind > bindgroup", "scopeId:", scopeId, "bindgroupId:", bindgroupId, "is not defined");
                return;
            }
            this.bindgroup[scopeId][bindgroupId] = false;
            this.attachedSurface.forEach(function (_ref5) {
                var srf = _ref5.surface;
                var canvas = _ref5.canvas;

                srf.updateBind();
            });
        }

        // 強制再描画
    }, {
        key: "render",
        value: function render() {
            this.attachedSurface.forEach(function (_ref6) {
                var srf = _ref6.surface;
                var canvas = _ref6.canvas;

                srf.render();
            });
        }
    }]);

    return Shell;
})(EventEmitter2);

exports.Shell = Shell;
},{"./Surface":5,"./SurfaceRender":6,"./SurfaceUtil":7}],5:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _slicedToArray = (function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; })();

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

var _get = function get(_x, _x2, _x3) { var _again = true; _function: while (_again) { var object = _x, property = _x2, receiver = _x3; desc = parent = getter = undefined; _again = false; if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { _x = parent; _x2 = property; _x3 = receiver; _again = true; continue _function; } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } } };

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _toArray(arr) { return Array.isArray(arr) ? arr : Array.from(arr); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

var _SurfaceRender = require("./SurfaceRender");

var _SurfaceUtil = require("./SurfaceUtil");

var SurfaceUtil = _interopRequireWildcard(_SurfaceUtil);

var $ = jQuery;

var Surface = (function (_EventEmitter2) {
    _inherits(Surface, _EventEmitter2);

    function Surface(canvas, scopeId, surfaceId, shell) {
        _classCallCheck(this, Surface);

        _get(Object.getPrototypeOf(Surface.prototype), "constructor", this).call(this);
        EventEmitter2.call(this);
        // public
        this.element = canvas;
        this.scopeId = scopeId;
        this.surfaceId = surfaceId;
        this.shell = shell;
        this.destructed = false;
        this.width = 0;
        this.height = 0;
        // private
        this.surfaceResources = shell.surfaceTree[surfaceId];
        this.bufferCanvas = SurfaceUtil.createCanvas();
        this.bufRender = new _SurfaceRender.SurfaceRender(this.bufferCanvas);
        this.elmRender = new _SurfaceRender.SurfaceRender(this.element);
        this.destructors = [];
        this.layers = {};
        this.stopFlags = {};
        this.talkCount = 0;
        this.talkCounts = {};
        this.animationsQueue = [];
        // initialize methods
        this.initMouseEvent();
        this.initAnimations();
        this.render();
    }

    // Shellから呼ばれるためpublic

    _createClass(Surface, [{
        key: "destructor",
        value: function destructor() {
            var _this = this;

            this.destructor = function () {
                return console.warn("this surface already destructed", _this);
            };
            this.destructors.forEach(function (fn) {
                return fn();
            });
            this.elmRender.clear();
            this.destructed = true;
            // これ以後のsetTimeoutトリガーのアニメーションを表示しない保険
            this.element = document.createElement("canvas");
            this.elmRender = new _SurfaceRender.SurfaceRender(this.element);
            this.layers = {};
        }
    }, {
        key: "render",
        value: function render() {
            var _this2 = this;

            // this.layersが数字をキーとした辞書なのでレイヤー順にソート
            var sorted = Object.keys(this.layers).sort(function (layerNumA, layerNumB) {
                return Number(layerNumA) > Number(layerNumB) ? 1 : -1;
            });
            var renderLayers = sorted.map(function (key) {
                return _this2.layers[Number(key)];
            }).reduce(function (arr, pattern) {
                var surface = pattern.surface;
                var type = pattern.type;
                var x = pattern.x;
                var y = pattern.y;

                if (surface === -1) return arr; // idが-1つまり非表示指定
                var srf = _this2.shell.surfaceTree[surface];
                if (srf == null) {
                    console.warn("Surface#render: surface id " + surface + " is not defined.", pattern);
                    console.warn(surface, Object.keys(_this2.shell.surfaceTree));
                    return arr; // 対象サーフェスがないのでスキップ
                }
                var base = srf.base;
                var elements = srf.elements;

                // 対象サーフェスのbaseサーフェス(surface*.png)の上に
                var rndr = new _SurfaceRender.SurfaceRender(SurfaceUtil.copy(base));
                // elementを合成する
                rndr.composeElements(elements);
                return arr.concat({
                    type: type,
                    x: x,
                    y: y,
                    canvas: rndr.cnv
                });
            }, []);
            var srfNode = this.surfaceResources;
            // this.surfaceIdが持つ情報。型をみて。
            this.bufRender.init(srfNode.base); // ベースサーフェスをバッファに描画。surface*.pngとかsurface *{base,*}とか
            this.bufRender.composeElements(srfNode.elements); // ベースサーフェスの上にエレメントを合成
            this.bufRender.composeElements(renderLayers); //現在有効なアニメーションのレイヤを合成
            if (this.shell.enableRegionDraw) {
                this.bufRender.ctx.fillText("" + this.surfaceId, 5, 10);
                this.bufRender.drawRegions(srfNode.collisions);
            }
            this.elmRender.init(this.bufRender.cnv); //バッファから実DOMTree上のcanvasへ描画
            this.width = this.element.width;
            this.height = this.element.height;
        }
    }, {
        key: "play",
        value: function play(animationId, callback) {
            var _this3 = this;

            var anims = this.surfaceResources.animations;
            var anim = this.surfaceResources.animations[animationId];
            if (!anim) return void setTimeout(callback);
            this.stopFlags[animationId] = false;
            this.animationsQueue[animationId] = anim.patterns.map(function (pattern) {
                return function () {
                    var surface = pattern.surface;
                    var wait = pattern.wait;
                    var type = pattern.type;
                    var x = pattern.x;
                    var y = pattern.y;
                    var animation_ids = pattern.animation_ids;

                    switch (type) {
                        case "start":
                            _this3.play(animation_ids[0], nextTick);
                            return;
                        case "stop":
                            _this3.stop(animation_ids[0]);
                            setTimeout(nextTick);
                            return;
                        case "alternativestart":
                            _this3.play(SurfaceUtil.choice(animation_ids), nextTick);
                            return;
                        case "alternativestart":
                            _this3.stop(SurfaceUtil.choice(animation_ids));
                            setTimeout(nextTick);
                            return;
                    }
                    _this3.layers[animationId] = pattern;
                    _this3.render();

                    var _ref = /(\d+)(?:\-(\d+))?/.exec(wait) || ["", "0", ""];

                    var _ref2 = _slicedToArray(_ref, 3);

                    var __ = _ref2[0];
                    var a = _ref2[1];
                    var b = _ref2[2];

                    var _wait = isFinite(Number(b)) ? SurfaceUtil.randomRange(Number(a), Number(b)) : Number(a);
                    setTimeout(nextTick, _wait);
                };
            });
            var nextTick = function nextTick() {
                var next = _this3.animationsQueue[animationId].shift();
                if (!(next instanceof Function) || _this3.destructed || !!_this3.stopFlags[animationId]) {
                    // stop pattern animation.
                    _this3.animationsQueue[animationId] = [];
                    setTimeout(callback);
                } else next();
            };
            this.animationsQueue[animationId][0] instanceof Function && this.animationsQueue[animationId][0]();
        }
    }, {
        key: "stop",
        value: function stop(animationId) {
            this.stopFlags[animationId] = true;
            this.animationsQueue[animationId] = [];
        }
    }, {
        key: "talk",
        value: function talk() {
            var _this4 = this;

            var animations = this.surfaceResources.animations;
            this.talkCount++;
            var hits = animations.filter(function (anim) {
                return (/^talk/.test(anim.interval) && _this4.talkCount % _this4.talkCounts[anim.is] === 0
                );
            });
            hits.forEach(function (anim) {
                _this4.play(anim.is);
            });
        }
    }, {
        key: "yenE",
        value: function yenE() {
            var _this5 = this;

            var animations = this.surfaceResources.animations;
            var hits = animations.filter(function (anim) {
                return anim.interval === "yen-e" && _this5.talkCount % _this5.talkCounts[anim.is] === 0;
            });
            hits.forEach(function (anim) {
                _this5.play(anim.is);
            });
        }

        // private methods
    }, {
        key: "initMouseEvent",
        value: function initMouseEvent() {
            var _this6 = this;

            this.initMouseEvent = function () {
                console.warn("initMouseEvent allows only first call. this call is second call.");
            };
            // 副作用あり
            var $elm = $(this.element);
            var tid = 0;
            var touchCount = 0;
            var touchStartTime = 0;
            var tuples = [];
            tuples.push(["contextmenu", function (ev) {
                return _this6.processMouseEvent(ev, "mouseclick");
            }]);
            tuples.push(["click", function (ev) {
                return _this6.processMouseEvent(ev, "mouseclick");
            }]);
            tuples.push(["dblclick", function (ev) {
                return _this6.processMouseEvent(ev, "mousedblclick");
            }]);
            tuples.push(["mousedown", function (ev) {
                return _this6.processMouseEvent(ev, "mousedown");
            }]);
            tuples.push(["mousemove", function (ev) {
                return _this6.processMouseEvent(ev, "mousemove");
            }]);
            tuples.push(["mouseup", function (ev) {
                return _this6.processMouseEvent(ev, "mouseup");
            }]);
            tuples.push(["touchmove", function (ev) {
                return _this6.processMouseEvent(ev, "mousemove");
            }]);
            tuples.push(["touchend", function (ev) {
                _this6.processMouseEvent(ev, "mouseup");
                _this6.processMouseEvent(ev, "mouseclick");
                if (Date.now() - touchStartTime < 500 && touchCount % 2 === 0) {
                    // ダブルタップ->ダブルクリック変換
                    _this6.processMouseEvent(ev, "mousedblclick");
                }
            }]);
            tuples.push(["touchstart", function (ev) {
                touchCount++;
                touchStartTime = Date.now();
                _this6.processMouseEvent(ev, "mousedown");
                clearTimeout(tid);
                tid = setTimeout(function () {
                    return touchCount = 0;
                }, 500);
            }]);
            // イベント登録
            tuples.forEach(function (_ref3) {
                var _ref32 = _slicedToArray(_ref3, 2);

                var ev = _ref32[0];
                var handler = _ref32[1];
                return $elm.on(ev, handler);
            });
            this.destructors.push(function () {
                // イベント解除
                tuples.forEach(function (_ref4) {
                    var _ref42 = _slicedToArray(_ref4, 2);

                    var ev = _ref42[0];
                    var handler = _ref42[1];
                    return $elm.off(ev, handler);
                });
            });
        }
    }, {
        key: "initAnimations",
        value: function initAnimations() {
            var _this7 = this;

            this.initAnimations = function () {
                console.warn("initAnimations allows only first call. this call is second call.");
            };
            // 副作用あり
            // このサーフェスのアニメーションを登録する
            this.surfaceResources.animations.forEach(function (anim) {
                _this7.initAnimation(anim);
            });
        }
    }, {
        key: "initAnimation",
        value: function initAnimation(anim) {
            var _this8 = this;

            // 副作用あり
            var animId = anim.is;
            var interval = anim.interval;
            var patterns = anim.patterns;
            //isってなんだよって話は @narazaka さんに聞いて。SurfacesTxt2Yamlのせい。
            var tmp = interval.split(",");
            var _interval = tmp[0];
            if (tmp.length > 1) {
                var n = Number(tmp[1]);
                if (!isFinite(n)) {
                    console.warn("initAnimation > TypeError: surface", this.surfaceId, "animation", anim.is, "interval", interval, " argument is not finite number");
                    n = 4; // rarelyにfaileback
                }
            }
            // アニメーション描画タイミングの登録
            switch (_interval) {
                // nextTickを呼ぶともう一回random
                case "sometimes":
                    SurfaceUtil.random(function (nextTick) {
                        if (!_this8.destructed && !_this8.stopFlags[animId]) {
                            _this8.play(animId, nextTick);
                        }
                    }, 2);
                    break;
                case "rarely":
                    SurfaceUtil.random(function (nextTick) {
                        if (!_this8.destructed && !_this8.stopFlags[animId]) {
                            _this8.play(animId, nextTick);
                        }
                    }, 4);
                    break;
                case "random":
                    SurfaceUtil.random(function (nextTick) {
                        if (!_this8.destructed && !_this8.stopFlags[animId]) {
                            _this8.play(animId, nextTick);
                        }
                    }, n);
                    break;
                case "periodic":
                    SurfaceUtil.periodic(function (nextTick) {
                        if (!_this8.destructed && !_this8.stopFlags[animId]) {
                            _this8.play(animId, nextTick);
                        }
                    }, n);
                    break;
                case "always":
                    SurfaceUtil.always(function (nextTick) {
                        if (!_this8.destructed && !_this8.stopFlags[animId]) {
                            _this8.play(animId, nextTick);
                        }
                    });
                    break;
                case "runonce":
                    this.play(animId);
                    break;
                case "never":
                    break;
                case "yen-e":
                    break;
                case "talk":
                    this.talkCounts[animId] = n;
                    break;
                default:
                    if (/^bind/.test(interval)) {
                        this.initBind(anim);
                        break;
                    }
                    console.warn("Surface#initAnimation > unkown SERIKO or MAYURA interval:", interval, anim);
            }
        }
    }, {
        key: "updateBind",
        value: function updateBind() {
            var _this9 = this;

            // Shell.tsから呼ばれるためpublic
            // Shell#bind,Shell#unbindで発動
            // shell.bindgroup[scopeId][bindgroupId] が変更された時に呼ばれるようだ
            this.surfaceResources.animations.forEach(function (anim) {
                var is = anim.is;
                var interval = anim.interval;
                var patterns = anim.patterns;

                if (/^bind/.test(interval)) {
                    _this9.initBind(anim);
                }
            });
        }
    }, {
        key: "initBind",
        value: function initBind(anim) {
            var _this10 = this;

            // kyuu ni nihongo utenaku natta.
            // initAnimation calls this method for animation interval type "bind".
            // updateBind calls this method.
            var is = anim.is;
            var interval = anim.interval;
            var patterns = anim.patterns;
            var option = anim.option;

            if (!this.shell.bindgroup[this.scopeId][is]) {
                delete this.layers[is];
                this.stop(is);
                return;
            }

            var _interval$split = interval.split("+");

            var _interval$split2 = _toArray(_interval$split);

            var _bind = _interval$split2[0];

            var intervals = _interval$split2.slice(1);

            if (intervals.length > 0) return;
            intervals.forEach(function (itvl) {
                _this10.initAnimation({ interval: itvl, is: is, patterns: patterns, option: option });
            });
            this.layers[is] = patterns[patterns.length - 1];
            this.render();
        }
    }, {
        key: "getRegion",
        value: function getRegion(offsetX, offsetY) {
            var _this11 = this;

            // canvas左上からの座標の位置が透明かそうでないか、当たり判定領域か、名前があるかを調べるメソッド
            // 副作用なし
            if (SurfaceUtil.isHit(this.element, offsetX, offsetY)) {
                var hitCols = this.surfaceResources.collisions.filter(function (collision, colId) {
                    var type = collision.type;
                    var name = collision.name;
                    var left = collision.left;
                    var top = collision.top;
                    var right = collision.right;
                    var bottom = collision.bottom;
                    var coordinates = collision.coordinates;
                    var radius = collision.radius;
                    var center_x = collision.center_x;
                    var center_y = collision.center_y;

                    switch (type) {
                        case "rect":
                            return left < offsetX && offsetX < right && top < offsetY && offsetY < bottom || right < offsetX && offsetX < left && bottom < offsetX && offsetX < top;
                        case "ellipse":
                            var width = Math.abs(right - left);
                            var height = Math.abs(bottom - top);
                            return Math.pow((offsetX - (left + width / 2)) / (width / 2), 2) + Math.pow((offsetY - (top + height / 2)) / (height / 2), 2) < 1;
                        case "circle":
                            return Math.pow((offsetX - center_x) / radius, 2) + Math.pow((offsetY - center_y) / radius, 2) < 1;
                        case "polygon":
                            var ptC = { x: offsetX, y: offsetY };
                            var tuples = coordinates.reduce(function (arr, _ref5, i) {
                                var x = _ref5.x;
                                var y = _ref5.y;

                                arr.push([coordinates[i], !!coordinates[i + 1] ? coordinates[i + 1] : coordinates[0]]);
                                return arr;
                            }, []);
                            var deg = tuples.reduce(function (sum, _ref6) {
                                var _ref62 = _slicedToArray(_ref6, 2);

                                var ptA = _ref62[0];
                                var ptB = _ref62[1];

                                var vctA = [ptA.x - ptC.x, ptA.y - ptC.y];
                                var vctB = [ptB.x - ptC.x, ptB.y - ptC.y];
                                var dotP = vctA[0] * vctB[0] + vctA[1] * vctB[1];
                                var absA = Math.sqrt(vctA.map(function (a) {
                                    return Math.pow(a, 2);
                                }).reduce(function (a, b) {
                                    return a + b;
                                }));
                                var absB = Math.sqrt(vctB.map(function (a) {
                                    return Math.pow(a, 2);
                                }).reduce(function (a, b) {
                                    return a + b;
                                }));
                                var rad = Math.acos(dotP / (absA * absB));
                                return sum + rad;
                            }, 0);
                            return deg / (2 * Math.PI) >= 1;
                        default:
                            console.warn("unkown collision type:", _this11.surfaceId, colId, name, collision);
                            return false;
                    }
                });
                if (hitCols.length > 0) return { isHit: true, name: hitCols[hitCols.length - 1].name };
                return { isHit: true, name: "" };
            } else {
                return { isHit: false, name: "" };
            }
        }
    }, {
        key: "processMouseEvent",
        value: function processMouseEvent(ev, type) {
            // マウスイベントの共通処理
            // 副作用なし。イベント発火する。
            $(ev.target).css({ "cursor": "default" });
            if (/^touch/.test(ev.type) && ev.originalEvent instanceof TouchEvent) {
                var _ev$originalEvent$changedTouches$0 = ev.originalEvent.changedTouches[0];
                var pageX = _ev$originalEvent$changedTouches$0.pageX;
                var pageY = _ev$originalEvent$changedTouches$0.pageY;
            } else {
                var pageX = ev.pageX;
                var pageY = ev.pageY;
            }

            var _$$offset = $(ev.target).offset();

            var left = _$$offset.left;
            var top = _$$offset.top;

            var offsetX = pageX - left; //canvas左上からのx座標
            var offsetY = pageY - top; //canvas左上からのy座標
            var hit = this.getRegion(offsetX, offsetY); //透明領域ではなかったら{name:当たり判定なら名前, isHit:true}
            ev.preventDefault();
            var custom = {
                "type": type,
                "offsetX": offsetX | 0,
                "offsetY": offsetY | 0,
                "wheel": 0,
                "scopeId": this.scopeId,
                "region": hit.name,
                "button": ev.button === 2 ? 1 : 0,
                "transparency": !hit.isHit,
                "event": ev // onした先でpriventDefaultとかstopPropagationとかしたいので
            };
            if (hit.name !== "") {
                if (/^touch/.test(ev.type)) {
                    ev.stopPropagation();
                }
                $(ev.target).css({ "cursor": "pointer" }); //当たり判定でマウスポインタを指に
            }
            this.emit("mouse", custom);
            this.shell.emit("mouse", custom);
        }
    }]);

    return Surface;
})(EventEmitter2);

exports.Surface = Surface;
},{"./SurfaceRender":6,"./SurfaceUtil":7}],6:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

var _createClass = (function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; })();

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var _SurfaceUtil = require("./SurfaceUtil");

var SurfaceUtil = _interopRequireWildcard(_SurfaceUtil);

var SurfaceRender = (function () {
    function SurfaceRender(cnv) {
        _classCallCheck(this, SurfaceRender);

        this.cnv = cnv;
        this.ctx = cnv.getContext("2d");
    }

    _createClass(SurfaceRender, [{
        key: "composeElements",
        value: function composeElements(elements) {
            if (elements.length === 0) {
                if (this.DEBUG) {
                    $("<hr />").appendTo(document.body);
                }
                return;
            }
            if (!Array.isArray(elements)) throw new Error("TypeError: elements is not array.");
            // elements is a array but it is like `a=[];a[2]="hoge";a[0] === undefined. so use filter.`
            var _elements$filter$0 = elements.filter(function (elm) {
                return !!elm;
            })[0];
            var canvas = _elements$filter$0.canvas;
            var type = _elements$filter$0.type;
            var x = _elements$filter$0.x;
            var y = _elements$filter$0.y;

            var offsetX = 0;
            var offsetY = 0;
            if (this.DEBUG) {
                var wrapper = document.createElement("fieldset");
                var prev = SurfaceUtil.copy(this.cnv);
                var adder = SurfaceUtil.copy(this.cnv);
                var __render = new SurfaceRender(adder);
                __render.clear();
                __render.overlay(canvas, offsetX + x, offsetY + y);
            }
            switch (type) {
                case "base":
                    this.base(canvas);
                    break;
                case "overlay":
                case "add":
                case "bind":
                    this.overlay(canvas, offsetX + x, offsetY + y);
                    break;
                case "overlayfast":
                    this.overlayfast(canvas, offsetX + x, offsetY + y);
                    break;
                case "replace":
                    this.replace(canvas, offsetX + x, offsetY + y);
                    break;
                case "interpolate":
                    this.interpolate(canvas, offsetX + x, offsetY + y);
                    break;
                case "move":
                    offsetX = x;
                    offsetY = y;
                    var copyed = SurfaceUtil.copy(this.cnv);
                    this.base(copyed);
                    break;
                case "asis":
                case "reduce":
                case "insert,ID":
                    break;
                default:
                    console.error(elements[0]);
            }
            if (this.DEBUG) {
                var result = SurfaceUtil.copy(this.cnv);
                $(wrapper).append($("<legend />").text(type + "(" + x + "," + y + ")")).append($("<style scoped />").html("\n        canvas{border:1px solid black;}\n      ")).append(prev).append("+").append(adder).append("=").append(result).appendTo(document.body);
            }
            this.composeElements(elements.slice(1));
        }
    }, {
        key: "clear",
        value: function clear() {
            this.cnv.width = this.cnv.width;
        }
    }, {
        key: "chromakey",
        value: function chromakey() {
            var ctx = this.cnv.getContext("2d");
            var imgdata = ctx.getImageData(0, 0, this.cnv.width, this.cnv.height);
            var data = imgdata.data;
            var r = data[0],
                g = data[1],
                b = data[2],
                a = data[3];
            var i = 0;
            if (a !== 0) {
                while (i < data.length) {
                    if (r === data[i] && g === data[i + 1] && b === data[i + 2]) {
                        data[i + 3] = 0;
                    }
                    i += 4;
                }
            }
            ctx.putImageData(imgdata, 0, 0);
        }
    }, {
        key: "pna",
        value: function pna(_pna) {
            var ctxB = _pna.getContext("2d");
            var imgdataA = this.ctx.getImageData(0, 0, this.cnv.width, this.cnv.height);
            var imgdataB = ctxB.getImageData(0, 0, _pna.width, _pna.height);
            var dataA = imgdataA.data;
            var dataB = imgdataB.data;
            var i = 0;
            while (i < dataA.length) {
                dataA[i + 3] = dataB[i];
                i += 4;
            }
            this.ctx.putImageData(imgdataA, 0, 0);
        }
    }, {
        key: "base",
        value: function base(part) {
            this.init(part);
        }
    }, {
        key: "overlay",
        value: function overlay(part, x, y) {
            if (this.cnv.width < part.width || this.cnv.height < part.height) {
                // baseのcanvasを拡大
                var tmp = SurfaceUtil.copy(this.cnv);
                this.cnv.width = part.width > this.cnv.width ? part.width : this.cnv.width;
                this.cnv.height = part.height > this.cnv.height ? part.height : this.cnv.height;
                this.ctx.drawImage(tmp, 0, 0);
            }
            this.ctx.globalCompositeOperation = "source-over";
            this.ctx.drawImage(part, x, y);
        }
    }, {
        key: "overlayfast",
        value: function overlayfast(part, x, y) {
            this.ctx.globalCompositeOperation = "source-atop";
            this.ctx.drawImage(part, x, y);
        }
    }, {
        key: "interpolate",
        value: function interpolate(part, x, y) {
            this.ctx.globalCompositeOperation = "destination-over";
            this.ctx.drawImage(part, x, y);
        }
    }, {
        key: "replace",
        value: function replace(part, x, y) {
            this.ctx.clearRect(x, y, part.width, part.height);
            this.overlay(part, x, y);
        }
    }, {
        key: "init",
        value: function init(cnv) {
            this.cnv.width = cnv.width;
            this.cnv.height = cnv.height;
            this.overlay(cnv, 0, 0); // type hack
        }
    }, {
        key: "initImageData",
        value: function initImageData(width, height, data) {
            this.cnv.width = width;
            this.cnv.height = height;
            var imgdata = this.ctx.getImageData(0, 0, width, height);
            var _data = imgdata.data; // type hack
            _data.set(data);
            this.ctx.putImageData(imgdata, 0, 0);
        }
    }, {
        key: "drawRegions",
        value: function drawRegions(regions) {
            var _this = this;

            regions.forEach(function (col) {
                _this.drawRegion(col);
            });
        }
    }, {
        key: "drawRegion",
        value: function drawRegion(region) {
            var type = region.type;
            var name = region.name;
            var left = region.left;
            var top = region.top;
            var right = region.right;
            var bottom = region.bottom;
            var coordinates = region.coordinates;
            var radius = region.radius;
            var center_x = region.center_x;
            var center_y = region.center_y;

            this.ctx.strokeStyle = "#00FF00";
            switch (type) {
                case "rect":
                    this.ctx.rect(left, top, right - left, bottom - top);
                    break;
                case "ellipse":
                    this.ctx.rect(left, top, right - left, bottom - top);
                    break;
                case "circle":
                    this.ctx.rect(left, top, right - left, bottom - top);
                    break;
                case "polygon":
                    this.ctx.rect(left, top, right - left, bottom - top);
            }
            this.ctx.stroke();
            this.ctx.font = "35px";
            this.ctx.strokeStyle = "white";
            this.ctx.strokeText(type + ":" + name, left + 5, top + 10);
            this.ctx.fillStyle = "black";
            this.ctx.fillText(type + ":" + name, left + 5, top + 10);
        }
    }]);

    return SurfaceRender;
})();

exports.SurfaceRender = SurfaceRender;

SurfaceRender.prototype.DEBUG = false;
},{"./SurfaceUtil":7}],7:[function(require,module,exports){
/**
 * extend deep like jQuery $.extend(true, target, source)
 */
"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.extend = extend;
exports.parseDescript = parseDescript;
exports.convert = convert;
exports.find = find;
exports.choice = choice;
exports.copy = copy;
exports.fetchPNGUint8ClampedArrayFromArrayBuffer = fetchPNGUint8ClampedArrayFromArrayBuffer;
exports.fetchImageFromArrayBuffer = fetchImageFromArrayBuffer;
exports.fetchImageFromURL = fetchImageFromURL;
exports.random = random;
exports.periodic = periodic;
exports.always = always;
exports.isHit = isHit;
exports.offset = offset;
exports.createCanvas = createCanvas;
exports.scope = scope;
exports.unscope = unscope;
exports.getEventPosition = getEventPosition;
exports.recursiveElementFromPoint = recursiveElementFromPoint;
exports.eventPropagationSim = eventPropagationSim;
exports.randomRange = randomRange;

function extend(target, source) {
    for (var key in source) {
        if (typeof source[key] === "object" && Object.getPrototypeOf(source[key]) === Object.prototype) {
            target[key] = target[key] || {};
            extend(target[key], source[key]);
        } else if (Array.isArray(source[key])) {
            target[key] = target[key] || [];
            extend(target[key], source[key]);
        } else if (source[key] !== undefined) {
            target[key] = source[key];
        }
    }
}

/**
 * "hoge.huga, foo, bar\n" to {"hoge.huga": "foo, bar"}
 */

function parseDescript(text) {
    text = text.replace(/(?:\r\n|\r|\n)/g, "\n"); // CRLF->LF
    while (true) {
        var match = (/(?:(?:^|\s)\/\/.*)|^\s+?$/g.exec(text) || ["", ""])[0];
        if (match.length === 0) break;
        text = text.replace(match, "");
    }
    var lines = text.split("\n");
    lines = lines.filter(function (line) {
        return line.length !== 0;
    }); // remove no content line
    var dic = lines.reduce(function (dic, line) {
        var tmp = line.split(",");
        var key = tmp[0];
        var vals = tmp.slice(1);
        key = key.trim();
        var val = vals.join(",").trim();
        dic[key] = val;
        return dic;
    }, {});
    return dic;
}

/**
 * convert some encoding txt file arraybuffer to js string
 */

function convert(buffer) {
    //return new TextDecoder('shift_jis').decode(buffer);
    return Encoding.codeToString(Encoding.convert(new Uint8Array(buffer), 'UNICODE', 'AUTO'));
}

/**
 * find filename that matches arg "filename" from arg "paths"
 */

function find(paths, filename) {
    filename = filename.split("\\").join("/");
    if (filename.slice(0, 2) === "./") filename = filename.slice(2);
    var reg = new RegExp("^" + filename.replace(".", "\.") + "$", "i");
    var hits = paths.filter(function (key) {
        return reg.test(key);
    });
    return hits;
}

function choice(arr) {
    return arr[Math.round(Math.random() * (arr.length - 1))];
}

function copy(cnv) {
    var _copy = document.createElement("canvas");
    var ctx = _copy.getContext("2d");
    _copy.width = cnv.width;
    _copy.height = cnv.height;
    ctx.drawImage(cnv, 0, 0); // type hack
    return _copy;
}

function fetchPNGUint8ClampedArrayFromArrayBuffer(pngbuf, pnabuf) {
    return new Promise(function (resolve, reject) {
        reject("deplicated");
        /*
        var reader = new PNGReader(pngbuf);
        var png = reader.parse();
        var dataA = png.getUint8ClampedArray();
        if(typeof pnabuf === "undefined"){
          var r = dataA[0], g = dataA[1], b = dataA[2], a = dataA[3];
          var i = 0;
          if (a !== 0) {
            while (i < dataA.length) {
              if (r === dataA[i] && g === dataA[i + 1] && b === dataA[i + 2]) {
                dataA[i + 3] = 0;
              }
              i += 4;
            }
          }
          return resolve(Promise.resolve({width: png.width, height: png.height, data: dataA}));
        }
        var pnareader = new PNGReader(pnabuf);
        var pna = pnareader.parse();
        var dataB = pna.getUint8ClampedArray();
        if(dataA.length !== dataB.length){
          return reject("fetchPNGUint8ClampedArrayFromArrayBuffer TypeError: png" +
          png.width+"x"+png.height+" and  pna"+pna.width+"x"+pna.height +
          " do not match both sizes");
        }
        var j = 0;
        while (j < dataA.length) {
          dataA[j + 3] = dataB[j];
          j += 4;
        }
        return resolve(Promise.resolve({width: png.width, height: png.height, data: dataA}));
        */
    })["catch"](function (err) {
        return Promise.reject("fetchPNGUint8ClampedArrayFromArrayBuffer msg:" + err + ", reason: " + err.stack);
    });
}

function fetchImageFromArrayBuffer(buffer, mimetype) {
    var url = URL.createObjectURL(new Blob([buffer], { type: mimetype || "image/png" }));
    return fetchImageFromURL(url).then(function (img) {
        URL.revokeObjectURL(url);
        return Promise.resolve(img);
    })["catch"](function (err) {
        return Promise.reject("fetchImageFromArrayBuffer > " + err);
    });
}

function fetchImageFromURL(url) {
    var img = new Image();
    img.src = url;
    return new Promise(function (resolve, reject) {
        img.addEventListener("load", function () {
            resolve(Promise.resolve(img)); // type hack
        });
        img.addEventListener("error", function (ev) {
            console.error("fetchImageFromURL", ev);
            reject("fetchImageFromURL ");
        });
    });
}

function random(callback, probability) {
    var ms = 1;
    while (Math.round(Math.random() * 1000) > 1000 / probability) {
        ms++;
    }
    setTimeout(function () {
        var nextTick = function nextTick() {
            return random(callback, probability);
        };
        callback(nextTick);
    }, ms * 1000);
}

function periodic(callback, sec) {
    setTimeout(function () {
        return callback(function () {
            return periodic(callback, sec);
        });
    }, sec * 1000);
}

function always(callback) {
    callback(function () {
        return always(callback);
    });
}

function isHit(cnv, x, y) {
    if (!(cnv.width > 0 || cnv.height > 0)) return false;
    var ctx = cnv.getContext("2d");
    var imgdata = ctx.getImageData(0, 0, x + 1 | 0, y + 1 | 0);
    var data = imgdata.data;
    return data[data.length - 1] !== 0;
}

function offset(element) {
    var obj = element.getBoundingClientRect();
    return {
        left: obj.left + window.pageXOffset,
        top: obj.top + window.pageYOffset,
        width: Math.round(obj.width),
        height: Math.round(obj.height)
    };
}

function createCanvas() {
    var cnv = document.createElement("canvas");
    cnv.width = 1;
    cnv.height = 1;
    return cnv;
}

// 0 -> sakura

function scope(scopeId) {
    return scopeId === 0 ? "sakura" : scopeId === 1 ? "kero" : "char" + scopeId;
}

// sakuta -> 0

function unscope(charId) {
    return charId === "sakura" ? 0 : charId === "kero" ? 1 : Number(/^char(\d+)/.exec(charId)[1]);
}

function getEventPosition(ev) {
    if (/^touch/.test(ev.type) && ev.originalEvent.touches.length > 0) {
        var pageX = ev.originalEvent.touches[0].pageX;
        var pageY = ev.originalEvent.touches[0].pageY;
        var clientX = ev.originalEvent.touches[0].clientX;
        var clientY = ev.originalEvent.touches[0].clientY;
        var screenX = ev.originalEvent.touches[0].screenX;
        var screenY = ev.originalEvent.touches[0].screenY;
        return { pageX: pageX, pageY: pageY, clientX: clientX, clientY: clientY, screenX: screenX, screenY: screenY };
    }
    var pageX = ev.pageX;
    var pageY = ev.pageY;
    var clientX = ev.clientX;
    var clientY = ev.clientY;
    var screenX = ev.screenX;
    var screenY = ev.screenY;
    return { pageX: pageX, pageY: pageY, clientX: clientX, clientY: clientY, screenX: screenX, screenY: screenY };
}

function recursiveElementFromPoint(ev, parent, target) {
    var _getEventPosition = getEventPosition(ev);

    var clientX = _getEventPosition.clientX;
    var clientY = _getEventPosition.clientY;
    var pageX = _getEventPosition.pageX;
    var pageY = _getEventPosition.pageY;

    var _$$offset = $(target).offset();

    var left = _$$offset.left;
    var top = _$$offset.top;

    var offsetX = clientX - (left - window.scrollX); // window.scrollX は position: fixed; でのclientWidthをとるため
    var offsetY = clientY - (top - window.scrollY);
    if ($(parent).find(target).length > 0 && target instanceof HTMLCanvasElement && isHit(target, offsetX, offsetY)) {
        eventPropagationSim(target, ev);
        return target;
    }
    var tmp = target.style.display;
    target.style.display = "none";
    var under = document.elementFromPoint(clientX, clientY);
    if (under == null) {
        target.style.display = tmp;
        return null;
    }
    if ($(parent).find(under).length > 0) {
        var result = recursiveElementFromPoint(ev, parent, under);
        target.style.display = tmp;
        return result;
    }
    eventPropagationSim(under, ev);
    target.style.display = tmp;
    // マウスを停止しているのにここを大量のmousemoveが通過するが
    // target.style.display = "none"したのち
    // target.style.display = tmp した瞬間に
    // mousemoveが発生してしまうためで、それほど大きな問題はないので大丈夫
    // (モバイルだとマウスないからmousemove発生しないし)
    return under;
}

function eventPropagationSim(target, ev) {
    ev.preventDefault();
    ev.stopPropagation();
    if (/^mouse|click$/.test(ev.type)) {
        var mev = new MouseEvent(ev.type, {
            screenX: ev.screenX,
            screenY: ev.screenY,
            clientX: ev.clientX,
            clientY: ev.clientY,
            ctrlKey: ev.ctrlKey,
            altKey: ev.altKey,
            shiftKey: ev.shiftKey,
            metaKey: ev.metaKey,
            button: ev.button,
            buttons: ev.originalEvent["buttons"],
            relatedTarget: ev.relatedTarget,
            view: ev.originalEvent["view"],
            detail: ev.originalEvent["detail"],
            bubbles: true
        });
        target.dispatchEvent(mev);
    } else if (/^touch/.test(ev.type)) {
        var ua = window.navigator.userAgent.toLowerCase();
        if (!(document.createTouch instanceof Function)) return console.warn(ua, "does not support document.createTouch");
        if (!(document.createTouchList instanceof Function)) return console.warn(ua, "does not support document.createTouchList");
        if (!(tev["initTouchEvent"] instanceof Function)) return console.warn(ua, "does not support TouchEvent#initTouchEvent");

        var _getEventPosition2 = getEventPosition(ev);

        var pageX = _getEventPosition2.pageX;
        var pageY = _getEventPosition2.pageY;
        var clientX = _getEventPosition2.clientX;
        var clientY = _getEventPosition2.clientY;
        var screenX = _getEventPosition2.screenX;
        var screenY = _getEventPosition2.screenY;

        var tev = document.createEvent("TouchEvent");
        var touch = document.createTouch(document.defaultView, ev.target, 0, pageX, pageY, screenX, screenY);
        var touches = document.createTouchList(touch);
        if (ua.indexOf('chrome') != -1 || ua.indexOf('opera') != -1) {
            console.info("this browser is chrome or opera", ua);
            tev["initTouchEvent"](touches, touches, touches, ev.type, ev.originalEvent["view"], screenX, screenY, clientX, clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey);
        } else if (ua.indexOf('safari') != -1) {
            console.info("this browser is safari", ua);
            tev["initTouchEvent"](ev.type, true, ev.cancelable, ev.originalEvent["view"], ev.originalEvent["detail"], screenX, screenY, clientX, clientY, ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, touches, touches, touches, 0, 0);
        } else if (ua.indexOf('firefox') != -1 || true) {
            console.info("this browser is firefox", ua);
            tev["initTouchEvent"](ev.type, true, ev.cancelable, ev.originalEvent["view"], ev.originalEvent["detail"], ev.ctrlKey, ev.altKey, ev.shiftKey, ev.metaKey, touches, touches, touches);
        }
        target.dispatchEvent(tev);
    } else {
        console.warn(ev.type, "is not support event");
    }
}

function randomRange(min, max) {
    return min + Math.floor(Math.random() * (max - min + 1));
}
},{}],8:[function(require,module,exports){
"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj["default"] = obj; return newObj; } }

var _Surface2 = require('./Surface');

var _Surface = _interopRequireWildcard(_Surface2);

var _SurfaceRender2 = require("./SurfaceRender");

var _SurfaceRender = _interopRequireWildcard(_SurfaceRender2);

var _SurfaceUtil2 = require("./SurfaceUtil");

var _SurfaceUtil = _interopRequireWildcard(_SurfaceUtil2);

var _Shell2 = require("./Shell");

var _Shell = _interopRequireWildcard(_Shell2);

var Surface = _Surface.Surface;
exports.Surface = Surface;
var SurfaceRender = _SurfaceRender.SurfaceRender;
exports.SurfaceRender = SurfaceRender;
var SurfaceUtil = _SurfaceUtil;
exports.SurfaceUtil = SurfaceUtil;
var Shell = _Shell.Shell;
exports.Shell = Shell;
},{"./Shell":4,"./Surface":5,"./SurfaceRender":6,"./SurfaceUtil":7}]},{},[3])(3)
});