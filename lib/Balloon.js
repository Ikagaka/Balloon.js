// Generated by CoffeeScript 1.10.0
(function() {
  var Balloon, Blimp, EventEmitter, SurfaceUtil,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  SurfaceUtil = require("ikagaka.shell.js").SurfaceUtil;

  Blimp = require("./Blimp");

  EventEmitter = require("eventemitter3");

  Balloon = (function(superClass) {
    extend(Balloon, superClass);

    function Balloon(directory1) {
      this.directory = directory1;
      Balloon.__super__.constructor.call(this);
      this.descript = {};
      this.attachedBlimp = [];
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function() {
      return Promise.resolve(this).then((function(_this) {
        return function() {
          return _this.loadDescript();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadBalloonSurfaces();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadBalloonDescripts();
        };
      })(this));
    };

    Balloon.prototype.loadDescript = function() {
      var descript_name, dir, getName;
      dir = this.directory;
      getName = (function(_this) {
        return function(dic, reg) {
          return Object.keys(dic).filter(function(name) {
            return reg.test(name);
          })[0] || "";
        };
      })(this);
      descript_name = getName(dir, /^descript\.txt$/i);
      if (descript_name === "") {
        console.info("descript.txt is not found");
        this.descript = {};
      } else {
        this.descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(dir[descript_name]));
      }
      return Promise.resolve(this);
    };

    Balloon.prototype.loadBalloonDescripts = function() {
      var balloons, descript, directory;
      directory = this.directory;
      balloons = this.balloons;
      descript = this.descript;
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var hits, keys;
          keys = Object.keys(directory);
          hits = keys.filter(function(filepath) {
            return /balloon([sk])(\d+)s\.txt$/.test(filepath);
          });
          hits.forEach(function(filepath) {
            var __, _descript, buffer, n, ref, type;
            buffer = directory[filepath];
            _descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(buffer));
            ref = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
            SurfaceUtil.extend(_descript, descript);
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)].descript = _descript;
              case "k":
                return balloons["kero"][Number(n)].descript = _descript;
            }
          });
          return resolve(_this);
        };
      })(this));
    };

    Balloon.prototype.loadBalloonSurfaces = function() {
      var balloons, directory, hits, keys, promises;
      directory = this.directory;
      balloons = this.balloons;
      keys = Object.keys(directory);
      hits = keys.filter(function(filepath) {
        return /[^\/]+\.png$/.test(filepath);
      });
      promises = hits.map(function(filepath) {
        var buffer;
        buffer = directory[filepath];
        return SurfaceUtil.createSurfaceCanvasFromArrayBuffer(buffer).then(function(arg) {
          var __, cnv, img, n, ref, ref1, ref2, type;
          img = arg.img, cnv = arg.cnv;
          if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
            ref = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = ref[0], type = ref[1], n = ref[2];
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)] = {
                  canvas: cnv
                };
              case "k":
                return balloons["kero"][Number(n)] = {
                  canvas: cnv
                };
              case "c":
                return balloons["communicate"][Number(n)] = {
                  canvas: cnv
                };
            }
          } else if (/^online(\d+)\.png$/.test(filepath)) {
            ref1 = /^online(\d+)\.png$/.exec(filepath), __ = ref1[0], n = ref1[1];
            return balloons["online"][Number(n)] = {
              canvas: cnv
            };
          } else if (/^arrow(\d+)\.png$/.test(filepath)) {
            ref2 = /^arrow(\d+)\.png$/.exec(filepath), __ = ref2[0], n = ref2[1];
            return balloons["arrow"][Number(n)] = {
              canvas: cnv
            };
          } else if (/^sstp\.png$/.test(filepath)) {
            return balloons["sstp"] = {
              canvas: cnv
            };
          } else if (/^thumbnail\.png$/.test(filepath)) {
            return balloons["thumbnail"] = {
              canvas: cnv
            };
          }
        });
      });
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return Promise.all(promises).then(function() {
            return resolve(_this);
          });
        };
      })(this));
    };

    Balloon.prototype.unload = function() {
      this.attachedBlimp.forEach(function(arg) {
        var blimp, element;
        element = arg.element, blimp = arg.blimp;
        return blimp.destructor();
      });
      this.removeAllListeners();
      Object.keys(this).forEach((function(_this) {
        return function(key) {
          return _this[key] = null;
        };
      })(this));
    };

    Balloon.prototype.attachBlimp = function(element, scopeId, balloonId) {
      var blimp, ref, type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (((ref = this.balloons[type]) != null ? ref[balloonId] : void 0) == null) {
        console.warn("balloon id:", balloonId, "is not defined");
        return null;
      }
      blimp = new Blimp(element, scopeId, balloonId, this);
      this.attachedBlimp.push({
        blimp: blimp,
        element: element
      });
      return blimp;
    };

    Balloon.prototype.detachBlimp = function(element) {
      var hits;
      hits = this.attachedBlimp.filter((function(_this) {
        return function(arg) {
          var _element;
          _element = arg.element;
          return _element === element;
        };
      })(this));
      if (hits.length === 0) {
        return;
      }
      hits[0].blimp.destructor();
      this.attachedBlimp.splice(this.attachedBlimp.indexOf(hits[0]), 1);
    };

    return Balloon;

  })(EventEmitter);

  module.exports = Balloon;

}).call(this);
