// Generated by CoffeeScript 1.10.0
(function() {
  var Balloon, Blimp, SurfaceRender, SurfaceUtil, ref,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = require("ikagaka.shell.js"), SurfaceRender = ref.SurfaceRender, SurfaceUtil = ref.SurfaceUtil;

  Blimp = require("./Blimp").Blimp;

  Balloon = (function(superClass) {
    extend(Balloon, superClass);

    function Balloon(directory1) {
      this.directory = directory1;
      Balloon.__super__.constructor.call(this);
      this.descript = {};
      this.attachedSurface = [];
      this.balloons = {
        "sakura": [],
        "kero": [],
        "communicate": [],
        "online": [],
        "arrow": [],
        "sstp": null,
        "thumbnail": null
      };
    }

    Balloon.prototype.load = function() {
      return Promise.resolve(this).then((function(_this) {
        return function() {
          return _this.loadDescript();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadBalloonSurfaces();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.loadBalloonDescripts();
        };
      })(this));
    };

    Balloon.prototype.loadDescript = function() {
      var descript_name, dir, getName;
      dir = this.directory;
      getName = (function(_this) {
        return function(dic, reg) {
          return Object.keys(dic).filter(function(name) {
            return reg.test(name);
          })[0] || "";
        };
      })(this);
      descript_name = getName(dir, /^descript\.txt$/i);
      if (descript_name === "") {
        console.info("descript.txt is not found");
        this.descript = {};
      } else {
        this.descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(dir[descript_name]));
      }
      return Promise.resolve(this);
    };

    Balloon.prototype.loadBalloonDescripts = function() {
      var balloons, descript, directory;
      directory = this.directory;
      balloons = this.balloons;
      descript = this.descript;
      return new Promise((function(_this) {
        return function(resolve, reject) {
          var hits, keys;
          keys = Object.keys(directory);
          hits = keys.filter(function(filepath) {
            return /balloon([sk])(\d+)s\.txt$/.test(filepath);
          });
          hits.forEach(function(filepath) {
            var __, _descript, buffer, n, ref1, type;
            buffer = directory[filepath];
            _descript = SurfaceUtil.parseDescript(SurfaceUtil.convert(buffer));
            ref1 = /balloon([sk])(\d+)s\.txt$/.exec(filepath), __ = ref1[0], type = ref1[1], n = ref1[2];
            SurfaceUtil.extend(_descript, descript);
            switch (type) {
              case "s":
                return balloons["sakura"][Number(n)].descript = _descript;
              case "k":
                return balloons["kero"][Number(n)].descript = _descript;
            }
          });
          return resolve(_this);
        };
      })(this));
    };

    Balloon.prototype.loadBalloonSurfaces = function() {
      var balloons, directory, hits, keys, promises;
      directory = this.directory;
      balloons = this.balloons;
      keys = Object.keys(directory);
      hits = keys.filter(function(filepath) {
        return /[^\/]+\.png$/.test(filepath);
      });
      promises = hits.map(function(filepath) {
        return new Promise(function(resolve, reject) {
          var buffer, url;
          buffer = directory[filepath];
          url = URL.createObjectURL(new Blob([buffer], {
            type: "image/png"
          }));
          return SurfaceUtil.fetchImageFromURL(url).then(function(img) {
            return [null, img];
          })["catch"](function(err) {
            return [err, null];
          }).then(function(arg) {
            var __, err, img, n, ref1, ref2, ref3, rndr, type;
            err = arg[0], img = arg[1];
            if (!!err) {
              return reject(err);
            }
            URL.revokeObjectURL(url);
            if (!!err) {
              return reject(err);
            }
            rndr = new SurfaceRender(SurfaceUtil.copy(img));
            rndr.chromakey();
            if (/^balloon([ksc])(\d+)\.png$/.test(filepath)) {
              ref1 = /^balloon([ksc])(\d+)\.png$/.exec(filepath), __ = ref1[0], type = ref1[1], n = ref1[2];
              switch (type) {
                case "s":
                  balloons["sakura"][Number(n)] = {
                    canvas: rndr.cnv
                  };
                  break;
                case "k":
                  balloons["kero"][Number(n)] = {
                    canvas: rndr.cnv
                  };
                  break;
                case "c":
                  balloons["communicate"][Number(n)] = {
                    canvas: rndr.cnv
                  };
              }
            } else if (/^online(\d+)\.png$/.test(filepath)) {
              ref2 = /^online(\d+)\.png$/.exec(filepath), __ = ref2[0], n = ref2[1];
              balloons["online"][Number(n)] = {
                canvas: rndr.cnv
              };
            } else if (/^arrow(\d+)\.png$/.test(filepath)) {
              ref3 = /^arrow(\d+)\.png$/.exec(filepath), __ = ref3[0], n = ref3[1];
              balloons["arrow"][Number(n)] = {
                canvas: rndr.cnv
              };
            } else if (/^sstp\.png$/.test(filepath)) {
              balloons["sstp"] = {
                canvas: rndr.cnv
              };
            } else if (/^thumbnail\.png$/.test(filepath)) {
              balloons["thumbnail"] = {
                canvas: rndr.cnv
              };
            }
            return resolve();
          });
        });
      });
      return new Promise((function(_this) {
        return function(resolve, reject) {
          return Promise.all(promises).then(function() {
            return resolve(_this);
          });
        };
      })(this));
    };

    Balloon.prototype.unload = function() {
      this.attachedBlimp.forEach(function(arg) {
        var blimp, element;
        element = arg.element, blimp = arg.blimp;
        return blimp.destructor();
      });
      this.removeAllListeners();
      Object.keys(this).forEach((function(_this) {
        return function(key) {
          return _this[key] = new _this[key].constructor();
        };
      })(this));
    };

    Balloon.prototype.attachBlimp = function(element, scopeId, balloonId) {
      var blimp, type;
      type = scopeId === 0 ? "sakura" : "kero";
      if (this.balloons[type][balloonId] == null) {
        console.warn("balloon id:", balloonId, "is not defined");
        return null;
      }
      blimp = new Blimp(element, scopeId, balloonId, this);
      this.attachedSurface.push({
        blimp: blimp,
        element: element
      });
      return blimp;
    };

    Balloon.prototype.detachBlimp = function(element) {
      var hits;
      hits = this.attachedBlimp.filter((function(_this) {
        return function(arg) {
          var _element;
          _element = arg.element;
          return _element === element;
        };
      })(this));
      if (hits.length === 0) {
        return;
      }
      hits[0].blimp.destructor();
      this.attachedBlimp.splice(this.attachedBlimp.indexOf(hits[0]), 1);
    };

    return Balloon;

  })(EventEmitter2);

  exports.Balloon = Balloon;

}).call(this);
