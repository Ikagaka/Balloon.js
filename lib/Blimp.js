// Generated by CoffeeScript 1.10.0
(function() {
  var $, Blimp, SurfaceUtil,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    slice = [].slice;

  SurfaceUtil = require("ikagaka.shell.js").SurfaceUtil;

  $ = require("jquery");

  Blimp = (function() {
    function Blimp(element, scopeId, balloonId1, balloon) {
      var balloonId, ref, ref1;
      this.element = element;
      this.scopeId = scopeId;
      this.balloonId = balloonId1;
      this.balloon = balloon;
      this.font = bind(this.font, this);
      this.showWait = bind(this.showWait, this);
      this.br = bind(this.br, this);
      this.clear = bind(this.clear, this);
      this.marker = bind(this.marker, this);
      this.talkraw = bind(this.talkraw, this);
      this.talk = bind(this.talk, this);
      this.choiceEnd = bind(this.choiceEnd, this);
      this.choiceBegin = bind(this.choiceBegin, this);
      this.choice = bind(this.choice, this);
      this.anchorEnd = bind(this.anchorEnd, this);
      this.anchorBegin = bind(this.anchorBegin, this);
      this.type = this.scopeId === 0 ? "sakura" : "kero";
      this.isBalloonLeft = true;
      balloonId = this.balloonId;
      if (!this.isBalloonLeft) {
        balloonId++;
      }
      this.descript = ((ref = this.balloon.balloons[this.type]) != null ? (ref1 = ref[balloonId]) != null ? ref1.descript : void 0 : void 0) || {};
      this.destructed = false;
      this.destructors = [];
      this.insertPoint = null;
      this.width = 0;
      this.height = 0;
      this.initDOMStructure();
      this.initEventListener();
      this.initStyleFromDescript();
      this.render();
    }

    Blimp.prototype.initDOMStructure = function() {
      this.$blimp = $(this.element).addClass("blimp");
      this.$blimpCanvas = $("<canvas width='0' height='0' />").addClass("blimpCanvas");
      this.$blimpText = $("<div />").addClass("blimpText");
      this.$blimp.append(this.$blimpCanvas);
      this.$blimp.append(this.$blimpText);
      this.$blimp.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "pointer-events": "auto"
      });
      this.$blimpCanvas.css({
        position: "absolute",
        top: "0px",
        left: "0px"
      });
      this.$blimpText.css({
        position: "absolute",
        top: "0px",
        left: "0px",
        "overflow-y": "scroll",
        "white-space": "pre-wrap",
        "word-wrap": "break-all"
      });
      $("<style scoepd />").text(".blimpText a {\n  cursor: pointer;\n}\n@keyframes blink {\n  75% { opacity: 0.0; }\n}\n.blimpText .blink {\n  animation: blink 1s step-end infinite;\n}").appendTo(this.$blimp);
      this.insertPoint = this.$blimpText;
    };

    Blimp.prototype.initEventListener = function() {
      var mouselistener, onanchorclick, onchoiceclick;
      mouselistener = (function(_this) {
        return function(ev) {
          var custom;
          custom = {
            type: ev.type,
            scopeId: _this.scopeId,
            balloonId: _this.balloonId,
            event: ev
          };
          return _this.balloon.emit("mouse", custom);
        };
      })(this);
      this.$blimp.on("click", mouselistener);
      this.$blimp.on("dblclick", mouselistener);
      this.$blimp.on("mousemove", mouselistener);
      this.$blimp.on("mousedown", mouselistener);
      this.$blimp.on("mouseup", mouselistener);
      onchoiceclick = (function(_this) {
        return function(ev) {
          var argc, event, i, j, ref;
          event = {
            type: "choiceselect",
            id: ev.target.dataset["id"],
            args: [],
            text: ev.target.textContent
          };
          argc = Number(ev.target.dataset["argc"]);
          for (i = j = 0, ref = argc; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            event.args.push(ev.target.dataset["argv" + i]);
          }
          return _this.balloon.emit("select", event);
        };
      })(this);
      this.$blimp.on("click", ".ikagaka-choice", onchoiceclick);
      onanchorclick = (function(_this) {
        return function(ev) {
          var argc, event, i, j, ref;
          event = {
            type: "anchorselect",
            id: ev.target.dataset["id"],
            args: [],
            text: ev.target.textContent
          };
          argc = Number(ev.target.dataset["argc"]);
          for (i = j = 0, ref = argc; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
            event.args.push(ev.target.dataset["argv" + i]);
          }
          return _this.balloon.emit("select", event);
        };
      })(this);
      this.$blimp.on("click", ".ikagaka-anchor", onanchorclick);
      this.destructors.push((function(_this) {
        return function() {
          _this.$blimp.off("click", mouselistener);
          _this.$blimp.off("dblclick", mouselistener);
          _this.$blimp.off("click", ".ikagaka-choice", onchoiceclick);
          return _this.$blimp.off("click", ".ikagaka-anchor", onanchorclick);
        };
      })(this));
    };

    Blimp.prototype.initStyleFromDescript = function() {
      var clickable_element_style, descript;
      descript = this.balloon.descript;
      this._text_style = {
        "cursor": descript["cursor"] || '',
        "font.name": (descript["font.name"] || "MS Gothic").split(/,/).map(function(name) {
          return '"' + name + '"';
        }).join(','),
        "font.height": (descript["font.height"] || "12") + "px",
        "font.color": this._getFontColor(descript["font.color.r"], descript["font.color.g"], descript["font.color.b"]),
        "font.shadowcolor": this._getFontColor(descript["font.shadowcolor.r"], descript["font.shadowcolor.g"], descript["font.shadowcolor.b"], true),
        "font.bold": descript["font.bold"],
        "font.italic": descript["font.italic"],
        "font.strike": descript["font.strike"],
        "font.underline": descript["font.underline"]
      };
      clickable_element_style = (function(_this) {
        return function(prefix, style_default, descript, can_ignore) {
          return {
            "style": {
              square: true,
              underline: true,
              'square+underline': true,
              none: true
            }[descript[prefix + ".style"]] ? descript[prefix + ".style"] : style_default,
            "font.color": _this._getFontColor(descript[prefix + ".font.color.r"], descript[prefix + ".font.color.g"], descript[prefix + ".font.color.b"], can_ignore),
            "pen.color": _this._getFontColor(descript[prefix + ".pen.color.r"], descript[prefix + ".pen.color.g"], descript[prefix + ".pen.color.b"], can_ignore),
            "brush.color": _this._getFontColor(descript[prefix + ".brush.color.r"], descript[prefix + ".brush.color.g"], descript[prefix + ".brush.color.b"], can_ignore)
          };
        };
      })(this);
      this._choice_style = clickable_element_style("cursor", "square", descript);
      this._choice_notselect_style = clickable_element_style("cursor.notselect", void 0, descript, true);
      this._anchor_style = clickable_element_style("anchor", "underline", descript);
      this._anchor_notselect_style = clickable_element_style("anchor.notselect", void 0, descript, true);
      this.$blimpText.css(this._blimpTextCSS(this._text_style));
      this._initializeCurrentStyle();
    };

    Blimp.prototype._blimpTextCSS = function(styles) {
      var css, text_decoration;
      css = {};
      css["cursor"] = styles["cursor"];
      css["font-family"] = styles["font.name"];
      css["font-size"] = styles["font.height"];
      css["color"] = styles["font.color"];
      css["background"] = "none";
      css["outline"] = "none";
      css["border"] = "none";
      css["text-shadow"] = styles["font.shadowcolor"] ? "1px 1px 0 " + styles["font.shadowcolor"] : "none";
      css["font-weight"] = styles["font.bold"] ? "bold" : "normal";
      css["font-style"] = styles["font.italic"] ? "italic" : "normal";
      text_decoration = [];
      if (styles["font.strike"]) {
        text_decoration.push('line-through');
      }
      if (styles["font.underline"]) {
        text_decoration.push('underline');
      }
      css["text-decoration"] = text_decoration.length ? text_decoration.join(' ') : "none";
      css["line-height"] = "1.2em";
      return css;
    };

    Blimp.prototype._blimpClickableTextCSS = function(styles, default_styles) {
      var background, border_bottom, color, outline;
      if (default_styles == null) {
        default_styles = {};
      }
      color = styles["font.color"] || default_styles["font.color"];
      outline = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      background = styles["brush.color"] || default_styles["brush.color"] || default_styles["font.color"];
      border_bottom = styles["pen.color"] ? "solid 1px " + styles["pen.color"] : default_styles["pen.color"] ? "solid 1px " + default_styles["pen.color"] : "solid 1px " + default_styles["font.color"];
      switch (styles["style"]) {
        case "square":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              "border-bottom": "none"
            }
          };
        case "underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              'border-bottom': border_bottom
            }
          };
        case "square+underline":
          return {
            base: {
              color: color
            },
            over: {
              outline: outline,
              background: background,
              'border-bottom': border_bottom
            }
          };
        case "none":
          return {
            base: {
              color: color
            },
            over: {
              outline: "none",
              background: "none",
              "border-bottom": "none"
            }
          };
        default:
          return {
            base: {},
            over: {}
          };
      }
    };

    Blimp.prototype._initializeCurrentStyle = function() {
      var name, ref, ref1, ref2, ref3, ref4, value;
      this._current_text_style = {};
      ref = this._text_style;
      for (name in ref) {
        value = ref[name];
        this._current_text_style[name] = value;
      }
      this._current_choice_style = {};
      ref1 = this._choice_style;
      for (name in ref1) {
        value = ref1[name];
        this._current_choice_style[name] = value;
      }
      this._current_choice_notselect_style = {};
      ref2 = this._choice_notselect_style;
      for (name in ref2) {
        value = ref2[name];
        this._current_choice_notselect_style[name] = value;
      }
      this._current_anchor_style = {};
      ref3 = this._anchor_style;
      for (name in ref3) {
        value = ref3[name];
        this._current_anchor_style[name] = value;
      }
      this._current_anchor_notselect_style = {};
      ref4 = this._anchor_notselect_style;
      for (name in ref4) {
        value = ref4[name];
        this._current_anchor_notselect_style[name] = value;
      }
    };

    Blimp.prototype._getFontColor = function(r, g, b, can_ignore) {
      var bc, gc, rc;
      rc = r != null ? r.replace(/%$/, '') : void 0;
      gc = g != null ? g.replace(/%$/, '') : void 0;
      bc = b != null ? b.replace(/%$/, '') : void 0;
      if ((isNaN(rc) || rc < 0) && (isNaN(gc) || gc < 0) && (isNaN(bc) || bc < 0)) {
        if (can_ignore) {

        } else {
          return "rgb(0,0,0)";
        }
      } else {
        return "rgb(" + r + "," + g + "," + b + ")";
      }
    };

    Blimp.prototype.location = function(x, y) {
      var $imp_position_checker, $newimp, $newimp_container, $newimp_container_top, baseoffset, offset, offsetx, offsety, re, toparam, xp, yp;
      re = /^(@)?(-?\d*\.?\d*e?\d*)(em|%)?$/;
      toparam = (function(_this) {
        return function(r) {
          var rp, unit, value;
          r = r + "";
          if (!r.length) {
            return {
              relative: true,
              value: 0
            };
          }
          rp = r.match(re);
          if (!rp) {
            return;
          }
          if (isNaN(rp[2])) {
            return;
          }
          if (rp[3] === '%') {
            value = rp[2] / 100;
            unit = 'em';
          } else {
            value = Number(rp[2]);
            unit = rp[3] || 'px';
          }
          return {
            relative: !!rp[1],
            value: value + unit
          };
        };
      })(this);
      xp = toparam(x);
      yp = toparam(y);
      if (!((xp != null) && (yp != null))) {
        return;
      }
      if (xp.relative || yp.relative) {
        $imp_position_checker = $('<span>.</span>');
        this.insertPoint.append($imp_position_checker);
        offset = $imp_position_checker.offset();
        baseoffset = this.$blimpText.offset();
        offsetx = offset.left - baseoffset.left;
        offsety = offset.top - baseoffset.top + this.$blimpText.scrollTop();
        $imp_position_checker.remove();
      }
      if (!xp.relative) {
        offsetx = 0;
      }
      if (!yp.relative) {
        offsety = 0;
      }
      $newimp_container_top = $('<div />').addClass("newimp_container_top").css({
        'position': 'absolute',
        'pointer-events': 'none',
        'top': yp.value
      });
      $newimp_container = $('<div />').addClass("newimp_container").css({
        'position': 'absolute',
        'pointer-events': 'none',
        'text-indent': offsetx + 'px',
        'top': offsety + 'px',
        'width': this.$blimpText[0].clientWidth
      });
      $newimp = $('<span />').css({
        'pointer-events': 'auto',
        'margin-left': xp.value
      });
      this.insertPoint = $newimp.appendTo($newimp_container.appendTo($newimp_container_top.appendTo(this.$blimpText)));
      this.insertPoint.css(this._blimpTextCSS(this._current_text_style));
    };

    Blimp.prototype.destructor = function() {
      this.destructor = (function(_this) {
        return function() {
          return console.warn("this blimp was already destructed", _this);
        };
      })(this);
      this.destructors.forEach((function(_this) {
        return function(fn) {
          return fn();
        };
      })(this));
      this.destructed = true;
      this.$blimp.removeClass("blimp");
      this.$blimp.children().remove();
      this.balloon = null;
    };

    Blimp.prototype.render = function() {
      var b, balloonId, baseCanvas, descript, h, l, r, ref, ref1, t, w;
      balloonId = this.balloonId;
      if (!this.isBalloonLeft) {
        balloonId++;
      }
      baseCanvas = this.balloon.balloons[this.type][balloonId].canvas;
      this.descript = ((ref = this.balloon.balloons[this.type]) != null ? (ref1 = ref[balloonId]) != null ? ref1.descript : void 0 : void 0) || {};
      SurfaceUtil.init(this.$blimpCanvas[0], this.$blimpCanvas[0].getContext("2d"), baseCanvas);
      this.$blimp.width(this.width = this.$blimpCanvas[0].width);
      this.$blimp.height(this.height = this.$blimpCanvas[0].height);
      descript = this.descript;
      t = descript["origin.y"] || descript["validrect.top"] || "10";
      r = descript["validrect.right"] || "10";
      b = descript["validrect.bottom"] || "10";
      l = descript["origin.x"] || descript["validrect.left"] || "10";
      w = this.$blimpCanvas[0].width;
      h = this.$blimpCanvas[0].height;
      this.$blimpText.css({
        top: t + "px",
        left: l + "px",
        width: (w - (Number(l) + Number(r))) + "px",
        height: (h - (Number(t) - Number(b))) + "px"
      });
    };

    Blimp.prototype.left = function() {
      this.isBalloonLeft = true;
      return this.render();
    };

    Blimp.prototype.right = function() {
      this.isBalloonLeft = false;
      return this.render();
    };

    Blimp.prototype.surface = function(balloonId) {
      balloonId - balloonId % 2;
      if (!this.isBalloonLeft) {
        balloonId++;
      }
      this.balloonId = balloonId;
      return this.render();
    };

    Blimp.prototype.anchorBegin = function() {
      var $a, _id, anchor_css, anchor_notselect_css, args, argv, id, index, j, len, text_css;
      id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.$blimpText.find(".blink").hide();
      this.$blimp.show();
      _id = $(document.createElement("div")).text(id).html();
      $a = $("<a />");
      $a.addClass("ikagaka-anchor");
      text_css = this._blimpTextCSS(this._current_text_style);
      anchor_css = this._blimpClickableTextCSS(this._current_anchor_style);
      anchor_notselect_css = this._blimpClickableTextCSS(this._current_anchor_notselect_style, this._current_anchor_style);
      $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
      $a.mouseover((function(_this) {
        return function() {
          return $a.css(anchor_css.over);
        };
      })(this));
      $a.mouseout((function(_this) {
        return function() {
          return $a.css(text_css).css(anchor_css.base).css(anchor_notselect_css.base).css(anchor_notselect_css.over);
        };
      })(this));
      $a.attr("data-id", _id);
      $a.attr("data-argc", args.length);
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        argv = args[index];
        $a.attr("data-argv" + index, argv);
      }
      this.originalInsertPoint = this.insertPoint;
      this.insertPoint = $a.appendTo(this.insertPoint);
    };

    Blimp.prototype.anchorEnd = function() {
      this.insertPoint = this.originalInsertPoint;
    };

    Blimp.prototype.choice = function() {
      var $a, _id, _text, args, argv, choice_css, choice_notselect_css, id, index, j, len, text, text_css;
      text = arguments[0], id = arguments[1], args = 3 <= arguments.length ? slice.call(arguments, 2) : [];
      this.$blimpText.find(".blink").hide();
      this.$blimp.show();
      _text = $(document.createElement("div")).text(text).html();
      _id = $(document.createElement("div")).text(id).html();
      $a = $("<a />");
      $a.addClass("ikagaka-choice");
      text_css = this._blimpTextCSS(this._current_text_style);
      choice_css = this._blimpClickableTextCSS(this._current_choice_style);
      choice_notselect_css = this._blimpClickableTextCSS(this._current_choice_notselect_style, this._current_text_style);
      $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
      $a.mouseover((function(_this) {
        return function() {
          return $a.css(choice_css.base).css(choice_css.over);
        };
      })(this));
      $a.mouseout((function(_this) {
        return function() {
          return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
        };
      })(this));
      $a.html(_text);
      $a.attr("data-id", _id);
      $a.attr("data-argc", args.length);
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        argv = args[index];
        $a.attr("data-argv" + index, argv);
      }
      $a.appendTo(this.insertPoint);
    };

    Blimp.prototype.choiceBegin = function() {
      var $a, _id, args, argv, choice_css, choice_notselect_css, id, index, j, len, text_css;
      id = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      this.$blimpText.find(".blink").hide();
      this.$blimp.show();
      _id = $(document.createElement("div")).text(id).html();
      $a = $("<a />");
      $a.addClass("ikagaka-choice");
      text_css = this._blimpTextCSS(this._current_text_style);
      choice_css = this._blimpClickableTextCSS(this._current_choice_style);
      choice_notselect_css = this._blimpClickableTextCSS(this._current_choice_notselect_style, this._current_text_style);
      $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
      $a.mouseover((function(_this) {
        return function() {
          return $a.css(choice_css.base).css(choice_css.over);
        };
      })(this));
      $a.mouseout((function(_this) {
        return function() {
          return $a.css(text_css).css(choice_notselect_css.base).css(choice_notselect_css.over);
        };
      })(this));
      $a.attr("data-id", _id);
      $a.attr("data-argc", args.length);
      for (index = j = 0, len = args.length; j < len; index = ++j) {
        argv = args[index];
        $a.attr("data-argv" + index, argv);
      }
      this.originalInsertPoint = this.insertPoint;
      this.insertPoint = $a.appendTo(this.insertPoint);
    };

    Blimp.prototype.choiceEnd = function() {
      this.insertPoint = this.originalInsertPoint;
    };

    Blimp.prototype.talk = function(text) {
      var _text;
      this.$blimpText.find(".blink").hide();
      _text = $(document.createElement("div")).text(text).html();
      if (!!this.currentSurface) {
        this.currentSurface.talk();
      }
      this.$blimp.show();
      this.insertPoint.append(_text);
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.talkraw = function(text) {
      this.$blimpText.find(".blink").hide();
      if (!!this.currentSurface) {
        this.currentSurface.talk();
      }
      this.$blimp.show();
      this.insertPoint.append(text);
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.marker = function() {
      var _text;
      this.$blimpText.find(".blink").hide();
      _text = $(document.createElement("div")).text("・").html();
      this.$blimp.show();
      this.insertPoint.append(_text);
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.clear = function() {
      this.$blimpText.html("");
      this.insertPoint = this.$blimpText;
      this._initializeCurrentStyle();
    };

    Blimp.prototype.br = function(ratio) {
      if (ratio != null) {
        this.location('0', '@' + ratio + 'em');
      } else {
        this.insertPoint.append("<br />");
      }
    };

    Blimp.prototype.showWait = function() {
      this.insertPoint.append("<br /><br />").append("<div class='blink'>▼</div>");
      this.$blimpText[0].scrollTop = 999;
    };

    Blimp.prototype.font = function() {
      var $newimp, $size_checker, is_text_style, name, size, treat_bool, treat_clickable_styles, value, values;
      name = arguments[0], values = 2 <= arguments.length ? slice.call(arguments, 1) : [];
      value = values[0];
      treat_bool = (function(_this) {
        return function(name, value) {
          if (value === 'default') {
            return _this._current_text_style["font." + name] = _this._text_style["font." + name];
          } else {
            return _this._current_text_style["font." + name] = !((value === 'false') || ((value - 0) === 0));
          }
        };
      })(this);
      treat_clickable_styles = (function(_this) {
        return function(treat_name, name, value, values, _current_style, _style) {
          switch (name) {
            case treat_name + "style":
              if (value === 'default') {
                return _current_style["style"] = _style["style"];
              } else {
                return _current_style["style"] = value;
              }
              break;
            case treat_name + "fontcolor":
              if (value === 'default') {
                return _current_style["font.color"] = _style["font.color"];
              } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                return _current_style["font.color"] = _this._getFontColor(values[0], values[1], values[2]);
              } else {
                return _current_style["font.color"] = value;
              }
              break;
            case treat_name + "pencolor":
              if (value === 'default') {
                return _current_style["pen.color"] = _style["pen.color"];
              } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                return _current_style["pen.color"] = _this._getpenColor(values[0], values[1], values[2]);
              } else {
                return _current_style["pen.color"] = value;
              }
              break;
            case treat_name + "color":
            case treat_name + "brushcolor":
              if (value === 'default') {
                return _current_style["brush.color"] = _style["brush.color"];
              } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
                return _current_style["brush.color"] = _this._getFontColor(values[0], values[1], values[2]);
              } else {
                return _current_style["brush.color"] = value;
              }
          }
        };
      })(this);
      switch (name) {
        case 'name':
          is_text_style = true;
          this._current_text_style["font.name"] = values.map(function(name) {
            return '"' + name + '"';
          }).join(',');
          break;
        case 'height':
          is_text_style = true;
          if (value === 'default') {
            this._current_text_style["font.height"] = this._text_style["font.height"];
          } else if (/^[+-]/.test(value)) {
            $size_checker = $('<span />').text('I').css({
              position: 'absolute',
              visibility: 'hidden',
              'width': '1em',
              'font-size': '1em',
              padding: 0,
              'line-height': '1em'
            });
            this.insertPoint.append($size_checker);
            size = $size_checker[0].clientHeight;
            $size_checker.remove();
            this._current_text_style["font.height"] = (Number(size) + Number(value)) + 'px';
          } else if (!isNaN(value)) {
            this._current_text_style["font.height"] = value + 'px';
          } else {
            this._current_text_style["font.height"] = value;
          }
          break;
        case 'color':
          is_text_style = true;
          if (value === 'default') {
            this._current_text_style["font.color"] = this._text_style["font.color"];
          } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
            this._current_text_style["font.color"] = this._getFontColor(values[0], values[1], values[2]);
          } else {
            this._current_text_style["font.color"] = value;
          }
          break;
        case 'shadowcolor':
          is_text_style = true;
          if (value === 'default') {
            this._current_text_style["font.shadowcolor"] = this._text_style["font.shadowcolor"];
          } else if (value === 'none') {
            this._current_text_style["font.shadowcolor"] = void 0;
          } else if ((values[0] != null) && (values[1] != null) && (values[2] != null)) {
            this._current_text_style["font.shadowcolor"] = this._getFontColor(values[0], values[1], values[2]);
          } else {
            this._current_text_style["font.shadowcolor"] = value;
          }
          break;
        case 'bold':
          is_text_style = true;
          treat_bool('bold', value);
          break;
        case 'italic':
          is_text_style = true;
          treat_bool('italic', value);
          break;
        case 'strike':
          is_text_style = true;
          treat_bool('strike', value);
          break;
        case 'underline':
          is_text_style = true;
          treat_bool('underline', value);
          break;
        case 'default':
          is_text_style = true;
          this._initializeCurrentStyle();
          break;
        case 'cursorstyle':
        case 'cursorfontcolor':
        case 'cursorpencolor':
        case 'cursorcolor':
        case 'cursorbrushcolor':
          treat_clickable_styles('cursor', name, value, values, this._current_choice_style, this._choice_style);
          break;
        case 'anchorstyle':
        case 'anchorfontcolor':
        case 'anchorpencolor':
        case 'anchorcolor':
        case 'anchorbrushcolor':
          treat_clickable_styles('anchor', name, value, values, this._current_anchor_style, this._anchor_style);
          break;
        case 'cursornotselectstyle':
        case 'cursornotselectfontcolor':
        case 'cursornotselectpencolor':
        case 'cursornotselectcolor':
        case 'cursornotselectbrushcolor':
          treat_clickable_styles('cursornotselect', name, value, values, this._current_choice_notselect_style, this._choice_notselect_style);
          break;
        case 'anchornotselectstyle':
        case 'anchornotselectfontcolor':
        case 'anchornotselectpencolor':
        case 'anchornotselectcolor':
        case 'anchornotselectbrushcolor':
          treat_clickable_styles('anchornotselect', name, value, values, this._current_anchor_notselect_style, this._anchor_notselect_style);
      }
      if (is_text_style) {
        $newimp = $('<span />');
        this.insertPoint = $newimp.appendTo(this.insertPoint);
        this.insertPoint.css(this._blimpTextCSS(this._current_text_style));
      }
    };

    return Blimp;

  })();

  module.exports = Blimp;

}).call(this);
